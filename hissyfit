#!/usr/bin/perl -CS

#  Ascii histogram.
#  -  default Unicode block glyphs u2581-u2588, --plain for retro-style.
#  -  number of bins (--bins, default 80)
#  -  y-axis scale (--height), resolution is N times this (default N=8).
#  -  Optional subselection of data (--min --max)
#  -  --cumulative 
#  -  quartiles indicated

use Getopt::Long;
use strict;
use warnings;
use utf8;

my $progname   = 'hissyfit';
my @ARGV_COPY  =  @ARGV;
my $n_args     =  @ARGV;
my $help       =  0;
my $debug      =  0;

my $cumulative =  0;
my $height     =  20;
my $SUBLEVELS  =  8;      # capitals for constants maybe
my $user_min   =  undef;
my $user_max   =  undef;
my $plain      =  0;
my $NBINS      =  80;
my $zilch      =  ' ';

my $staircase  = '‚ñÅ-‚ñÇ-‚ñÉ-‚ñÑ-‚ñÖ-‚ñÜ-‚ñá-‚ñà';
my $stairsep   = '-';
my $emoji      =  0;
my $emosep     =  'üêô';

sub help {
   print <<EOH;
Usage:
   $progname [options]
Options:
--help            this
--bins=NUM        use this number of bins (default $NBINS)
--height=NUM      number of lines (default $height); resolution is N * NUM
                  where N=8 by default, 5 with --plain, or user-specified with --stairs
--min=NUM         use as boundary (selects as well)
--max=NUM         use as boundary (selects as well)
--plain           revert to plain ascii
--cumulative      print cumulative histogram

--stairs=x-y[-z]* use these as cursor sublevels (argument will split on '$stairsep' or --sep)
--stair-sep=X     use X as separator to split stairs (default $stairsep)
--zilch=S         use S as filler for histogram (default space)
EOH
}

if
(! GetOptions
   (  "help"            =>   \$help
   ,  "plain"           =>   \$plain
   ,  "debug"           =>   \$debug
   ,  "cumulative"      =>   \$cumulative
   ,  "height=i"        =>   \$height
   ,  "bins=i"          =>   \$NBINS
   ,  "min=f"           =>   \$user_min
   ,  "max=f"           =>   \$user_max
   ,  "stairs=s"        =>   \$staircase
   ,  "stair-sep=s"     =>   \$stairsep
   ,  "zilch=s"         =>   \$zilch
   ,  "emoji"           =>   \$emoji
   ,  "emoji_"          =>   \$emosep
   )
)
   {  print STDERR "option processing failed\n";
      exit(1);
   }

if ($help) { help(); exit(0); }

if ($plain) {
  $staircase = ".,-,:,',|";
  $stairsep = ',';
}
elsif ($emoji) {
                     # say hi to flushed, woozy, monocle, grinning and sunglasses.
  $staircase = 'üò≥-ü•¥-üßê-üòÄ-üòé';
  $zilch = '  ' unless $zilch ne ' ';      #  Used to have this guy: üò∞
  $NBINS = 20 if $NBINS == 80;
}

die "Bins in [10,1000] please or edit code\n" unless $NBINS >= 10 && $NBINS <= 1000;

my @D = ();
while (<>) {
  chomp;
  push @D, $_;
}

die "No data\n" if !@D;

@D = sort { $a <=> $b} @D;
my $dmin  = $D[0];
my $dmax  = $D[-1];

my $q1 = $D[int(@D/4)];       # Not going to sweat ties or even off-by-1.
my $q2 = $D[int(@D/2)];       # What they said.
my $q3 = $D[int(3*@D/4)];     # ^

my $hmin = $dmin;
my $hmax = $dmax;

my $out_of_range = 0;
if (defined($user_min)) {
  my $umin = $user_min;
  $out_of_range++ if $umin > $dmin;
  $hmin = $umin;
}
if (defined($user_max)) {
  my $umax = $user_max;
  $out_of_range++ if $umax < $dmax;
  $hmax = $umax;
}

my $ND_orig   = @D;

if ($out_of_range) {
  @D = grep { $_ >= $hmin && $_ <= $hmax } @D;
}
my $ND = @D;
die "No data present in bounds [$hmin, $hmax]\n" if !@D;


##    This is input done.
##    Now compute histogram data.

my $width = ($hmax-$hmin) / $NBINS;

my @H = ();                         #  histogram data

my $N_run = 0;
my $threshold_1 = $hmin;
my $threshold_2 = $hmin + $width;
my $index = 0;
my $d = 0;
my $N_assigned = 0;

while ($d < @D && $index < $NBINS) {
  my $item = $D[$d];
  if ($item >= $threshold_1 && $item < $threshold_2) {
    $N_run++;
    $d++;
  }
  elsif ($item >= $threshold_2) {
    $H[$index] = $N_run;
    $N_assigned += $N_run;
    $N_run = 0;
    $index++;
    $threshold_1  = $threshold_2;
    $threshold_2  = $hmin + ($index+1) * $width;
  }
}

if ($N_run) {
   die "run error\n" if $index == $NBINS;
   $H[$index++] = $N_run;
   $N_assigned += $N_run;
}
while ($index < $NBINS) {          # can happen under various circumstances, e.g. user boundaries.
  $H[$index] = 0;
  $index++;
}
$H[$NBINS-1] += ($ND-$N_assigned);    # this controls for floating point addition causing boundary issues. 

my $lh = @H;
die "hist error ($lh)\n" unless @H == $NBINS;

local $" = ' ';
print STDERR "hval(@H)\n" if $debug;


##    This binned the data in a rather painful way.
##    Now cumulative data is easy. We need it always, e.g. for quartiles.


my @C = ($H[0]);          #  cumulative histogram data
for (my $i=1;$i<$NBINS; $i++) {
   $C[$i] = $C[$i-1] + $H[$i];
}


##    This is histogram data done.
##    Now set some paint parameters, compute a few stats.


my @canvas = ();
my %map = ();

my @stairs = split($stairsep, $staircase);
$SUBLEVELS = @stairs;
my $bigbrick = $stairs[$SUBLEVELS-1];
for (my $j=1;$j<@stairs;$j++) {
  $map{$j} = $stairs[$j-1];
}

my $bigbin = ( sort { $b <=> $a } @H )[0];
my $bigbinid = (grep { $H[$_] == $bigbin } 0..($NBINS-1))[0] + 1;   # 1-based for user.
my $bigbinmid = $hmin + ($bigbinid-0.5)*$width;
my $Ymax = $cumulative ? $ND : $bigbin;


##    Parameters set.
##    Paint the canvas, transposed.


my $NUNIT = $height * $SUBLEVELS;           # this variable needs capitals.

# local $" = ' ';
# print STDERR "-- (@D) (@H) (@C) $Ymax\n";

for (my $i=0;$i<$NBINS;$i++) {
  my $n = $cumulative ? $C[$i] : $H[$i];
  my $nunit = int($NUNIT*$n/$Ymax);         # support maxinum of $NUNIT steps.
  my $Nrem  = $nunit % $SUBLEVELS;          # one char represents $SUBLEVELS $NUNITs.
  my $Nfull = ($nunit - $Nrem) / $SUBLEVELS;
  die "sum error\n" if $Nfull + ($Nrem > 0) > $height;
  my $Nzilch = $height - $Nfull - ($Nrem > 0);
  $canvas[$i] = [ ($bigbrick) x $Nfull ];
  push @{$canvas[$i]}, $map{$Nrem} if $Nrem;
  push @{$canvas[$i]}, ($zilch) x $Nzilch;
  die "canvas paint error\n" unless @{$canvas[$i]} == $height;
}


##    Canvas done.
##    Give it to the nice people.


for (my $u=0; $u<$height; $u++) {
  for (my $v=0; $v<$NBINS;$v++) {
    print $canvas[$v][$height-$u-1];
  }
  print "\n";
}


##    Canvas given.
##    Print some stats, go to some lengths to plot quartile locations.


my $sep = '____.____,' x 100;
$sep = substr($sep, 0, $NBINS);

if ($NBINS >= 80) {
  my $sep_a = sprintf("%.1f ", $hmin);
  my $sep_z = sprintf(" %.1f", $hmax);

  substr($sep, 0, length($sep_a)) = $sep_a;
  substr($sep, length($sep) - length($sep_z), length($sep_z)) = $sep_z;
}

$sep = $emosep x $NBINS if $emoji;

if ($q1 > $hmin && $q3 < $hmax && $ND >= 20) {

   my $p1 = (grep { $C[$_] > 0 && $D[$C[$_]-1] >= $q1 } 0..($NBINS-1))[0];
   my $p2 = (grep { $C[$_] > 0 && $D[$C[$_]-1] >= $q2 } 0..($NBINS-1))[0];
   my $p3 = (grep { $C[$_] > 0 && $D[$C[$_]-1] >= $q3 } 0..($NBINS-1))[0];

print STDERR "c99=$C[$NBINS-1] nd=$ND q=$q1,$q2,$q3 ql=$p1,$p2,$p3  qlv=$D[$C[$p1]-1],$D[$C[$p2]-1],$D[$C[$p3]-1]\n" if $debug;

   substr($sep, $p1, 1) = $emoji ? 'üåò' : 'Q';
   substr($sep, $p2, 1) = $emoji ? 'üåó' : 'Q';
   substr($sep, $p3, 1) = $emoji ? 'üåñ' : 'Q';
}

print "$sep\n";

my $oor = "";
if ($out_of_range) {
  my $N_out_of_range = $ND_orig - $ND;
  $oor = ' oor=' . $N_out_of_range . sprintf("/%.1f", 100 * $N_out_of_range / $ND_orig) . '%';
}

my $bigbinpct = sprintf("%.1f", 100 * $bigbin / $ND_orig);
print "ND=$ND$oor hmin=$hmin hmax=$hmax dmin=$dmin dmax=$dmax\n";
print "topbin(i=$bigbinid,n=$bigbin,p=$bigbinpct,x~$bigbinmid) bw=$width q=($q1,$q2,$q3)\n";

