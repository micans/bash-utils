#!/usr/bin/perl

  #                     Copyright (c) 2022-2023  Stijn van Dongen
  #      
  #      Permission is hereby granted, free of charge, to any person obtaining a copy
  #      of this software and associated documentation files (the "Software"), to deal
  #      in the Software without restriction, including without limitation the rights
  #      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  #      copies of the Software, and to permit persons to whom the Software is
  #      furnished to do so, subject to the following conditions:
  #      
  #      The above copyright notice and this permission notice shall be included in all
  #      copies or substantial portions of the Software.
  #      
  #      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  #      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  #      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  #      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  #      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  #      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  #      SOFTWARE.

use strict;
use warnings;
use Digest::MD5 qw(md5_hex);
use POSIX;

       ##                                                                               ##
      ##      Pick columns and select rows from tabular input, add derived columns       ##
     ##                 Pick and select either by column name or index                    ##
    ##                 Add new columns, update existing columns in-place                   ##
    ##    Select with numerical and string comparison operators and regular expressions    ##
     ##               Select on either existing columns or derived columns                ##
      ##           Compute derived columns with string and arithmetic operations         ##
       ##                        Add or change column names                             ##
        ##             Select column names using regular expressions                   ##
        ##                                                                             ##
       ##                        Requires tab separated input                           ##
      ##                 See -H (EOH below) and -l (brief help)                          ##

@::spec = @ARGV; @ARGV = ();

sub helphelp {
   my $status = shift;
   print STDERR "Use -l (list) for concise help, -H for long help, -h suppresses header line output\n";
   print STDERR "Pick only works as a pipe, so invoke e.g. as: pick foo bar < data.txt\n";
   exit $status;
}

helphelp(0) unless @::spec;

@::output_nm  = ();         # names - (header|1..N) + compute handles
@::output_os  = ();         # names translated to offsets in @F (field array)
@::compute = ();            # derived column specifications
@::select  = ();            # row select specifications
%::handle_map = ();         # map column names to offsets
%::plain_handle = ();       # handles without any compute following.

my $PAT_IGNORE     = '';    # ::/my style is somewhat intractable. :: tend to be thing accessed in subroutines.
my $INSERT_OFFSET  = undef; # with -A, where to put extra columns (by default at the end).
my $OFFSET_OMEGA   = -1;    # with -O<N>, accept overflow ragged columns from position <N> onwards.

my $B_print_header = 1;     # B_oolean. Also accessed in subroutines.
my $B_select_and   = 1;     # Require all selections to match (use -o for any)
my $B_print_tally  = 0;     # Print trailing T column with count of selections matched
my $B_printall     = 0;     # Select all columns
my $B_inplace      = 0;     # Allow derived column to redefine existing column name
my $B_excise       = 0;     # print all except the plain column handles listed, cannot combine with $B_printall
my $B_add_row_column = 0;   # See -H, EOH
my $B_headless     = 0;     # No header (-k option)
my $B_ko           = 0;     # With -k, make output columns unique and ordered as in output.
my $B_sprouthead   = 0;     # Create header e.g. from derived names
my $B_weirdmode    = 0;     # Header exists, but users wants to use numbers (turns of selections for header)
my $B_force        = 0;     # Force output if identical output names exist
my $M_ignore       = 0;     # M_ode: 0 oblivious, 1 skip, 2 pass
my $B_debug        = 0;     # Mostly documents the stages of compute and selection definitions
my $B_verbose      = 0;     # Not terrifically interesting
my $B_add_names    = 0;     # If other names are given, whether to output them as column names
my $B_regex        = 1;     # Whether to interpret names as a regular expression if one of the characters in $REGEXP_CHARS is found
my $B_protect      = 0;     # Some protection against divide-by-zero; modifiable with PICK_*_INF environment variables.

$::EPSILON         = 0.0001;  # obvs the best default epsilon - 10,000 is a myriad.
$::OOM             = 2;     # order of magnitude. Maybe sqrt(2) makes more sense.

my $REGEXP_CHARS   = '[({\\\*?^$';

sub stacky { die "$_[0] stack error\n" unless @::STACK >= $_[1]; }

my %PNAN =                  # Protect against division by zero etc. Defaults exist and can be overridden.
(  PICK_LOG10_INF => 10000
,  PICK_LOG_INF   => 10000
,  PICK_TAN_INF   => 'inf'
,  PICK_DIV_INF   => '-'
)  ;
for (keys %PNAN) { $PNAN{$_} = $ENV{$_} if defined($ENV{$_}); }

                            # Nearly all of the below push 1 item on the stack after consuming X.
                            # Only X is specified; X = 0 indicate exceptional cases.
                            # Potentially neatify this by adding Y (number of pushed items).
my %cp_opdefinitions =
   ( add       => [ 2, sub { $::STACK[-2] += $::STACK[-1] } ],
     addall    => [ 0, sub { my $x = 0; $x += $_ for @::STACK; @::STACK = ($x) } ],
     maxall    => [ 0, sub { my $x = -POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ > $x }; @::STACK = ($x) } ],
     minall    => [ 0, sub { my $x =  POSIX::DBL_MAX; for (@::STACK) { $x = $_ if $_ < $x }; @::STACK = ($x) } ],
     joinall   => [ 1, sub { my $j = pop(@::STACK); my $x = join $j, @::STACK; @::STACK = ($x) } ],
     mul       => [ 2, sub { $::STACK[-2] *= $::STACK[-1] } ],
     div       => [ 2, sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? $x / $y : $PNAN{PICK_DIV_INF} } ],
     idiv      => [ 2, sub { my ($x, $y) = @::STACK[-2,-1]; $::STACK[-2] = !$B_protect || $y ? ($x-($x % $y))/$y : $PNAN{PICK_DIV_INF} } ],
     cat       => [ 2, sub { $::STACK[-2] .= $::STACK[-1] } ],
     sub       => [ 2, sub { $::STACK[-2] -= $::STACK[-1] } ],
     pop       => [ 0, sub { stacky('pop', 1); pop @::STACK } ],
     dup       => [ 0, sub { stacky('dup', 1); push @::STACK, $::STACK[-1]  } ],
     xch       => [ 0, sub { stacky('xch', 2); ($::STACK[-2], $::STACK[-1]) = ($::STACK[-1], $::STACK[-2]) } ],
     rowno     => [ 0, sub { push @::STACK, $::Nrows -1+$B_headless } ],
     lineno    => [ 0, sub { push @::STACK, $.      } ],
     mod       => [ 2, sub { $::STACK[-2] %= $::STACK[-1] } ],
     pow       => [ 2, sub { $::STACK[-2] **= $::STACK[-1] } ],
     and       => [ 2, sub { $::STACK[-2] &= $::STACK[-1] } ],
     or        => [ 2, sub { $::STACK[-2] |= $::STACK[-1] } ],
     xor       => [ 2, sub { $::STACK[-2] ^= $::STACK[-1] } ],
     max       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] > $::STACK[-2] } ],
     min       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] < $::STACK[-2] } ],
     dd        => [ 2, sub { $::STACK[-2] = sprintf("%.*f", $::STACK[-1], $::STACK[-2]) } ],
     zp        => [ 2, sub { my $l = $::STACK[-1] - length($::STACK[-2]); $l = 0 if $l < 0; $::STACK[-2] = '0' x $l . $::STACK[-2] } ],

     get       => [ 2, sub { my $item =  $::STACK[-2] =~ qr/$::STACK[-1]/
                                         ? (defined($1) ? $1 : $&) : ""; $::STACK[-2] = $item; } ],
     uie       => [ 2, sub { $::STACK[-2] = $::STACK[-1] unless length($::STACK[-2]) } ],

     cgsum     => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'sum') } ],
     cgmax     => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'max') } ],
     cgcount   => [ 2, sub { $::STACK[-2] = acigar($::STACK[-2], $::STACK[-1], 'count') } ],
     cgrefcov  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MDN=X', 'sum') } ],
     cgqrycov  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MI=X', 'sum') } ],
     cgqrylen  => [ 1, sub { $::STACK[-1] = acigar($::STACK[-1], 'MIS=X', 'sum') } ],
     cgqryend  => [ 1, sub { my $e = acigar($::STACK[-1], 'MIS=X', 'sum'); $e -= $1 if $::STACK[-1] =~ /(\d+)S$/; $::STACK[-1] = $e } ],
     cgqrystart=> [ 1, sub { my $s = 1; $s += $1 if $::STACK[-1] =~ /^(\d+)S/; $::STACK[-1] = $s } ],

     ed        => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/  } ],
     edg       => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/g } ],
     map       => [ 2, sub { my ($x, $d) = @::STACK[-2,-1]; my $dict = $::dict{$d}; my $m = defined($dict) ? $dict->{$x} : undef; $::STACK[-2] = $m if defined($m); } ],
     substr    => [ 3, sub { $::STACK[-3] =  substr($::STACK[-3], $::STACK[-2], $::STACK[-1]) } ],
     pct       => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y ? sprintf("%.*f", $n, $x * 100 / $y) : $PNAN{PICK_DIV_INF} } ],
     frac      => [ 3, sub { my ($x, $y, $n) = @::STACK[-3,-2,-1]; $::STACK[-3] = !$B_protect || $y ? sprintf("%.*f", $n, $x / $y) :  $PNAN{PICK_DIV_INF}} ],

     tobin     => [ 1, sub { $::STACK[-1] = sprintf("%b", $::STACK[-1]) } ],
     tohex     => [ 1, sub { $::STACK[-1] = sprintf("%x", $::STACK[-1]) } ],
     tooct     => [ 1, sub { $::STACK[-1] = sprintf("%o", $::STACK[-1]) } ],
     binto     => [ 1, sub { $::STACK[-1] = oct("0b$::STACK[-1]") } ],
     hexto     => [ 1, sub { $::STACK[-1] = hex($::STACK[-1]) } ],
     octto     => [ 1, sub { $::STACK[-1] = oct($::STACK[-1]) } ],
     urldc     => [ 1, sub { $::STACK[-1] = urldecode($::STACK[-1]) } ],
     urlec     => [ 1, sub { $::STACK[-1] = urlencode($::STACK[-1]) } ],
     uc        => [ 1, sub { $::STACK[-1] = uc($::STACK[-1]) }         ],
     lc        => [ 1, sub { $::STACK[-1] = lc($::STACK[-1]) }         ],
     rev       => [ 1, sub { $::STACK[-1] = reverse($::STACK[-1]) }    ],
     rot13     => [ 1, sub { $::STACK[-1] =~ tr/a-zA-Z/n-za-mN-ZA-M/ } ],
     md5       => [ 1, sub { $::STACK[-1] = md5_hex($::STACK[-1]) }    ],
     len       => [ 1, sub { $::STACK[-1] = length($::STACK[-1]) }     ],
     rc        => [ 1, sub { $::STACK[-1] =~ tr/acgtuACGTU/tgcaaTGCAA/; $::STACK[-1] = reverse($::STACK[-1]) } ],
     abs       => [ 1, sub { $::STACK[-1] = abs($::STACK[-1]) }        ],
     sqrt      => [ 1, sub { $::STACK[-1] = sqrt($::STACK[-1]) }       ],
     sq        => [ 1, sub { $::STACK[-1] = $::STACK[-1]**2 }          ],
     exp       => [ 1, sub { $::STACK[-1] = exp($::STACK[-1]) }        ],
     cos       => [ 1, sub { $::STACK[-1] = cos($::STACK[-1]) }        ],
     sin       => [ 1, sub { $::STACK[-1] = sin($::STACK[-1]) }        ],
     tan       => [ 1, sub { my $c = cos($::STACK[-1]); $::STACK[-1] = !$B_protect || $c ? sin($::STACK[-1])/$c : $PNAN{PICK_TAN_INF} } ],
     log       => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1]) : $PNAN{PICK_LOG_INF} }        ],
     log10     => [ 1, sub { $::STACK[-1] = !$B_protect || $::STACK[-1] ? log($::STACK[-1])/log(10) : $PNAN{PICK_LOG10_INF} }],
     exp10     => [ 1, sub { $::STACK[-1] = 10**$::STACK[-1] }         ],
     sign      => [ 1, sub { $::STACK[-1] = $::STACK[-1] > 0 ? 1 : $::STACK[-1] < 0 ? -1 : 0 } ],
     ceil      => [ 1, sub { $::STACK[-1] = ceil($::STACK[-1]) }       ],
     floor     => [ 1, sub { $::STACK[-1] = floor($::STACK[-1]) }      ],
     int       => [ 1, sub { $::STACK[-1] = int($::STACK[-1]) }        ],
   );

            # sub { } :
            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
            # For /ep/ and /om/ third argument is $::EPSILON/$::OOM or specified suffix.
            # 40 41 etc just to keep sort order when outputting list of select ops,
            # as '/' is overloaded in a slightly confusing way (negation and num op delimiter),
            # as is '~' (matching and string op delimiter). This keeps them grouped together.
            #
my %sel_opdefinitions = (
  '~'          => [ 40, sub { $_[0] =~ /$_[1]/ } ],
  '/~'         => [ 41, sub { $_[0] !~ /$_[1]/ } ],
  '='          => [ 42, sub { $_[0]  eq $_[1]  } ],
  '/='         => [ 43, sub { $_[0]  ne $_[1]  } ],

  '/eq/'       => [ 44, sub { $_[0] == $_[1] } ],
  '/ne/'       => [ 45, sub { $_[0] != $_[1] } ],
  '/lt/'       => [ 46, sub { $_[0] <  $_[1] } ],
  '/le/'       => [ 47, sub { $_[0] <= $_[1] } ],
  '/ge/'       => [ 48, sub { $_[0] >= $_[1] } ],
  '/gt/'       => [ 49, sub { $_[0] >  $_[1] } ],

  '/ep/'       => [ 50, sub { interval_plus(@_)} ],
  '/om/'       => [ 51, sub { interval_mul(@_) } ],

  '~eq~'       => [ 52, sub { $_[0] eq $_[1] } ],
  '~ne~'       => [ 53, sub { $_[0] ne $_[1] } ],
  '~lt~'       => [ 54, sub { $_[0] lt $_[1] } ],
  '~le~'       => [ 55, sub { $_[0] le $_[1] } ],
  '~ge~'       => [ 56, sub { $_[0] ge $_[1] } ],
  '~gt~'       => [ 57, sub { $_[0] gt $_[1] } ],

     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/'      => [ 58, sub { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) } ],
  '/any/'      => [ 59, sub { abs(int($_[0])) & abs(int($_[1])) } ],
  '/none/'     => [ 60, sub { ! (abs(int($_[0])) & abs(int($_[1]))) } ]

);

my $envsettings = join "\n", map { sprintf("  %-20s %8s", $_, $PNAN{$_}) } keys %PNAN;

my $help_options=q{Options:
  -h do not print header
  -o OR multiple select criteria (default is AND)
  -x take complement of selected input column(s) (works with -i)
  -i in-place: <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -/<pat>  skip lines matching <pat>; use e.g. -/^# for commented lines, -/^@ for sam files
  -//<pat> pass through lines matching <pat>
     <pat> allows perl regular expressions, e.g. ^ $ . [] * ? (|) work.
  -v verbose

  -A print all input columns (selecting by colspec applies, -T accepted)
  -A<N> <N> integer; insert new columns at position <N>. Negative <N> is relative to rightmost column.
  -O<N> <N> integer; allow ragged input (e.g. SAM use -O12), merge all columns at/after position <N>
  -T do not select, print tally column of count of matched row select criteria (name T)
  -P protect against 'nan' and 'inf' results (see -H for environment variables PICK_*_INF)

  -k headerless input, use 1 2 .. for input column names
     x-y for range from x to y
     a+x-y*k for range from a + k*x to a+y*k with incrementes of k 
  -K headerless input, as above, use derived names to output column names
  -U with -k and -K keep output columns unique and in original order

  -R add _ column variable if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically
  -f force processing (allows both identical input and output column names)
  -F fixed names; do not interpret names as regular expressions.
     Default behaviour is to assume a regular expression if a name contains one of [ \{ ( \ * ?
  -W (weird mode) header exists but use 1 2 .. for column names (selection not applied to header)
    1. consider using a=longcolumnname b=longercolumname; pick $a $b @$b/gt/0 @$a/lt/0 < data.txt
    2. consider using --inames=CSV (see below; this will change names in the output)

  -z  ARG+ print url-encoding of ARG+  (no argument prints a few especially useful cases)
  -zz ARG+ print url-decoding of ARG+
  -l Concise help output
  -H Longer pick description

  --inames=CSV       comma-separated values to use as column names instead of actual column names.
  --add-inames=CSV   The list must cover all columns in the input. Names that are used
                     in selection, compute and filter expressions must be picked from this list.
                     Output names are from the list. If using -k --inames=CSV provides temporary
                     handles; use --add-inames=CSV to add them to the output.

  --fdict-NAME=fname fname should be two-column tab-separated file storing key and value per line.
                     This stores a dictionary called NAME that can be used to map values
                     with ...^NAME,map. Small dictionaries can be encoded on the command line with
  --cdict-NAME=<csv> where <csv> is a comma separated string of key:value pairs -- after splitting
                     on commas and colons all keys and values are url-decoded. Example usage:
       echo -e "a\t3\nb\t4" | ./pick -Aik --cdict-foo=a:Alpha,b:Beta 1::1^foo,map

  Short options combine, e.g. -ok/^@ for headerless input, comments indicated by ^@, OR selection.
  -AT is useful for inspecting/checking select criteria
  use -Ai <name>::<COMPUTE> to change column <name> to <COMPUTE>,
  use -Aik <num>::<COMPUTE> to change column <num> to <COMPUTE>.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (column name, index, or derived compute name)
  (2) @<HANDLE><op><VAL>       select criterion compare handle to constant value with <op>
  (3) @<HANDLE><op>:<HANDLE2>  select criterion compare handle to other handle with <op>
  (4) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output

  COMPUTE: <part>+ where <part> is one of ^<value> :<handle> ,<operator>
  Later computes have access to HANDLEs that were computed before.

  HANDLE[2], VAL and handles and values in COMPUTE are all URL-decoded.
  URL-encoding is generally necessary for characters in [%:^/~]. Use pick -z <string>
  to find the url-encoding of <string> .};

my @normalops = grep { $_ !~ /all$/ } keys %cp_opdefinitions;
my @ops1 = sort grep { $cp_opdefinitions{$_}[0] == 1 } @normalops;
my @ops2 = sort grep { $cp_opdefinitions{$_}[0] == 2 } @normalops;
my @ops3 = sort grep { $cp_opdefinitions{$_}[0] == 3 } @normalops;
# selectops
my @opsf = sort { $sel_opdefinitions{$a}[0] <=> $sel_opdefinitions{$b}[0] } keys %sel_opdefinitions;
my $nameslist = "";

%::dict = ();

sub read_dict {
   my ($name, $fname) = @_;
   open(D, "<$fname") || die "cannot open $fname for dictionary reading";
   while(<D>) {
      chomp; my @F = split "\t";
      die "Dictionary $name load error on line $. of $fname" unless @F >= 2;
      $::dict{$name}{$F[0]} = $F[1];
   } close(D);
   my $n = keys %{$::dict{$name}};
print STDERR "-- have $n keys in dictionary $name after reading $fname\n" if $B_verbose;
}

sub parse_dict {
   my ($name, $string) = @_;
   for my $pair (split ",", $string) {
      my ($k, $v) = map { urldecode($_) } split ':', $pair;
      die "no key:value found in [$pair]" unless defined($v);
      $::dict{$name}{$k} = $v;
   }
   my $n = keys %{$::dict{$name}};
print STDERR "-- have $n keys in dictionary $name after parsing string\n" if $B_verbose;
}

while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;

  if ($options =~ /^--fdict-(\w+)=(.+)$/) {
    read_dict($1, $2);
    next;
  }
  elsif ($options =~ /^--cdict-(\w+)=(.+)$/) {
    parse_dict($1, $2);
    next;
  }
  elsif ($options =~ /^--(add-)?inames=(.+)$/) {
    $nameslist=$2;
    $B_add_names = $1 ? 1 : 0;
    next;
  }
  ($PAT_IGNORE, $M_ignore) = ($1, 2) if $options =~ s/\/\/(.*)$//;
  ($PAT_IGNORE, $M_ignore) = ($1, 1) if $options =~ s/\/([^\/].*)$//;

  if ($options =~ s/O(\d+)//) {
     $OFFSET_OMEGA = $1 + 0;
     die "-O<N> N must be positive\n" unless $OFFSET_OMEGA > 0;
  }

  if ($options =~ s/A(-?\d+)?//) {
     $B_printall     = 1;
     if (defined($1)) {
        $INSERT_OFFSET = $1 + 0;
     }
  }

  $B_print_header = 0 if $options =~ s/h//;
  $B_regex        = 0 if $options =~ s/F//;
  $B_protect      = 1 if $options =~ s/P//;
  $B_select_and   = 0 if $options =~ s/o//;
  $B_verbose      = 1 if $options =~ s/v//;
  $B_ko           = 1 if $options =~ s/U//;
  $B_print_tally  = 1 if $options =~ s/T//;
  $B_excise       = 1 if $options =~ s/x//;
  $B_add_row_column =1 if $options =~ s/R//;
  $B_headless     = 1 if $options =~ s/k//;
  ($B_headless, $B_sprouthead)= (1, 1) if $options =~ s/K//;
  ($B_headless, $B_weirdmode) = (1, 1) if $options =~ s/W//;
  $B_debug        = 1 if $options =~ s/d//;
  $B_force        = 1 if $options =~ s/f//;
  $B_inplace      = 1 if $options =~ s/i//;

  if ($options =~ s/(z+)//) {
    local $, = ' ';
    print map { length($1) % 2 == 1 ? urlencode($_) : urldecode($_) } @::spec;
    if (@::spec) { print "\n"; }
    else { print STDERR <<EOH;
-- I url-encode any arguments. Useful cases:
  ^   %5E         <TAB>      %09
  :   %3A         <NEWLINE>  %0A
  ,   %2C         <CR>       %0D
  %   %25         <SPACE>    %20
EOH
    }
    exit 0;
  }
  elsif ($options =~ s/l//) {
    print $help_options, "\n";
    print "\nSelect/compute forms:$spec_forms\n";
    print "\nOperators for compute:\n";
    print "  Stack control:  dup pop xch\n";
    print "  Input counters: lineno rowno\n";
    print "  Stack devourers: addall minall maxall joinall\n";
    print "  Take 1: @ops1\n";
    print "  Take 2: @ops2\n";
    print "  Take 3: @ops3\n";
    print "\nSelect comparison operators:\n";
    print "  @opsf\n";
    print "\nSee -H for longer descriptions and some operator explanations.\n";
    exit 0;
  }
  elsif ($options =~ /H/) {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
  See further below for <op> list.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a select criterion comparing a handle to a constant value. 
Form (3) creates a select criterion comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op><VAL>
@<COLNAME><op>:<COLNAME>  select rows based on <VAL> or value in column <COLNAME>.

<op> is one of the following:
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/<what>/epsilon  Aproximate numerical identity wrt <what> +- epsilon
  /om/<what>/oom      Aproximate magnitude identity wrt |<what>| * oom
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> and <handle> will be url-decoded. In particular, if you
  need one of [%^:,/~] in <string> it is best to url-encode it with 25, 5E, 3A,
  2C, 2F, 7E respectively; use pick -z <string> to find its URL-encoded form.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).

  If the very first part starts with anything other than [,:^] it is inferred
  to be a handle (leading : not needed).  <COMPUTE> is a stack, so
  zut::foo:bar,add^str,cat creates a new column called zut by adding columns
  foo and bar and then concatenating 'str'. The default operation is
  concatenation; if no operators are left the remainder of the stack is
  concatenated. Thus the above is equivalent to zut::foo:bar,add^str. To just
  prefix a column: zut::^foo:zut To concatenate two columns: zut::foo:bar .
  Below: examples/explanations for some operators that may not be self-explanatory.

Explaining the self-unexplained
   stack   op            result
   ------+------------+-------------------------------------------------------------------
   x e   | get        |  x =~ s/e/MATCH/   | MATCH is \$1 corresponding to outer () if exists,
   x e z | ed         |  x =~ s/e/z/       | matched part otherwise.
   x e z | edg        |  x =~ s/e/z/g      | e accepts most perl regular expression syntax
   x d   | map        |  map x using dictionary named d, specified as --fdict-d=<FNAME>  
   x y   | uie        |  (use if empty) x or y if x is the empty string
   x n   | zp         |  left-padding with zeroes to length n
   x o n | substr     |  substr(x, o=offset, n=count)
   x y n | pct        |  x as percentage of y with n decimals | '-' if y is zero
   x y n | frac       |  x as fraction of y with n decimals   |
   x n   | dd         |  x rounded to n decimals
   c s   | cgsum      |  sum of lengths of s items in cigar string c  | s subset of MINDSHP=X
   c s   | cgmax      |  max of lengths of s items in cigar string c  |
   c s   | cgcount    |  count of s items in cigar string c           |
   c     | cgqrylen   |  equivalent to "c MIS=X cgsum" (query length)
   ..    | addall     |  sum of elements in the stack (similarly minall maxall)
   .. s  | joinall    |  all elements in the stack joined using string s

Environment variables with default settings:
$envsettings

List of <op>
  Stack control  | dup pop xch
  Input counters | lineno rowno
  Take 1 | @ops1
  Take 2 | @ops2
  Take 3 | @ops3
EOH
  exit 0;
  }
  if ($options ne '-') {
    print STDERR "Option string not fully parsed: $options remains\n";
    exit 1;
  }
}

die "-O<N> requires -k\n" if $OFFSET_OMEGA > 0 && !$B_headless;

$B_print_header = 0 if $B_headless;
$B_print_header = 1 if $B_add_names;

@::nameslist = $nameslist ? split ',', $nameslist : ();

helphelp(1) unless @::spec || $B_printall || $B_excise;

sub interval_plus {
  my ($x, $y, $val) = @_;
  my $epsilon = $val ? $val : $::EPSILON;
  return $x <= $y + $epsilon && $x >= $y - $epsilon;
}

sub interval_mul {
  my ($x, $y, $val) = @_;
  my $oom = $val ? $val : $::OOM;
  return abs($x) <= abs($y) * $oom && abs($x) >= abs($y) / $oom;
}


my $TYPE_SCALAR = 1;
my $TYPE_HANDLE = 2;
my $TYPE_OPATOR = 3;    # (1) rule of six obvs, (2) it makes sense in Dutch.

my %chartypetonum = ( '^', $TYPE_SCALAR, ':', $TYPE_HANDLE, ',', $TYPE_OPATOR );

sub parse_compute {
  my ($handle, $spec) = @_;
  my @oplist = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[,^:]/;
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]*)/g) {
    my ($type, $what) = ($chartypetonum{$1}, $2);
    $what = urldecode($what) if $type == $TYPE_SCALAR || $type == $TYPE_HANDLE;     #constant.
    push @oplist, [$type, $what];
    $p = pos($spec);
    if ($type == $TYPE_OPATOR) {
      my $opdef = $cp_opdefinitions{$what};
      die "Not supported [$what]\n" unless defined($opdef);
                           # N stack required, code.
      push @{$oplist[-1]}, ($opdef->[0], $opdef->[1]);
print STDERR "-- $handle >> type=$type op=$what N=$opdef->[0], code=$opdef->[1]\n" if $B_debug;
    }
    else {
print STDERR "-- $type $what >>\n" if $B_debug;
    }
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oplist;
}

sub urlencode {
   my $val = shift;
   $val =~ s/([^A-Za-z0-9_])/ uc sprintf "%%%0x", ord $1 /eg;
   return $val;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


sub acigar {

   my ($cigar, $subset, $mode) = @_;
   my $key = "cigar::$cigar";
   my @subset = split "", $subset;

   if (!defined($::LINECACHE{$key})) {
      my $c = $::LINECACHE{$key} =
        { sum   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , max   => { map { ($_, 0)  } split "", 'MINDSHP=X' }
        , count => { map { ($_, 0)  } split "", 'MINDSHP=X' } };
      my $p = 0; my $n = 0;
      while ($cigar =~ m/(\d+)([MIDNSHP=X])/ig) {
        my ($num, $it) = ($1, $2);
        $n += length($&);
        $c->{sum}{$it} += $num;
        $c->{count}{$it}++;
        $c->{max}{$it} = $num if $num > $c->{max}{$it};
        $p = pos($cigar);
      }
print STDERR "-- Unmatched part in cigar string $cigar at $p (line $.)\n" unless $p == length($cigar) && $n == length($cigar);
   }
   my $cache = $::LINECACHE{$key};
   if ($mode eq 'max')      { my $max = 0; for my $x (@subset) { $max = $cache->{max}{$x} if $cache->{max}{$x} > $max }; return $max }
   elsif ($mode eq 'sum')   { my $sum = 0; $sum += $cache->{sum}{$_} for @subset; return $sum }
   elsif ($mode eq 'count') { my $count = 0; $count += $cache->{count}{$_} for @subset; return $count }
   else                     { return 'NA' }
}

sub add_column {
  print "\t" if $::N_column_output++; print $_[0];
}

sub wrangle_header {

  if ($::HEADER[0] eq '')   { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_'; }

  $::N = @::HEADER;
  my %inheader = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name}) && !defined($B_force);
    $::handle_map{$name} = $i;   
print STDERR "-- map header name $name to offset $i\n" if $B_debug;
  }

  for my $spec (@::spec) {
    if ($spec =~ /(.*?)(:[:=])(.*)/) {
      my ($handle, $type, $compute) = (urldecode($1), $2, $3);
      if ($handle =~ /[$REGEXP_CHARS]/ && $B_regex) {
        my @matches = grep { $_ =~ qr/$handle/ } @::HEADER;
        my $n_matches = @matches; local $" = ' ';
print STDERR "-- (output+compute) expanding pattern $handle ($n_matches matches: @matches)\n" if $B_verbose || !$n_matches;
        $compute = ":$compute" unless $compute =~ /^[,:^]/;
        for my $m (@matches) {
          my $compute_m = $compute; $compute_m =~ s/:__\b/:$m/g;
          my $parsed_compute = parse_compute($handle, $compute_m);
          push @::compute, [$m, $parsed_compute];
          push @::output_nm, $m if $type eq '::';
        }
      }
      else {
        my $parsed_compute = parse_compute($handle, $compute);
        push @::compute, [$handle, $parsed_compute];
        push @::output_nm, $handle if $type eq '::';
      }
    }
                  #  H handle
                  #  a1a2a3, b, c, d different forms for op
                  #  V value or :handle
                  #    ( H )([ a1](      a2    )[ a3]|  b    | c | d )( V)(  arg )
    elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~]|[=~]{1}|\/=|\/~)(.*?)(\/.*?)?$/) {
      my ($handle, $op, $val, $arg) = (urldecode($1), $2, urldecode($3), $4);      #constant
      die "Unrecognised operator [$op]\n" unless defined($sel_opdefinitions{$op});
      if (defined($arg)) {
        die "Extra argument currently only allowed for /ep/ and /om/" unless $op =~ /^\/(ep|om)\/$/;
        $arg=urldecode($arg);      #constant
      }
      else{
         $arg = 0;
      }
print STDERR "-- adding select criterion handle=[$handle] op=[$op] val=[$val] arg=[$arg]\n" if $B_debug;
      my $indirection = $val =~ s/^:// ? 1 : 0;
      push @::select, [$op, $indirection, $val, $handle, $arg];
               # NOTE. $arg for now only used by /ep/ and /om/ selection, ignored by the others.
    }
    elsif ($B_headless && $spec =~ /^((\d+)\+)?(\d+)-(\d+)(\*(\d+))?$/) {
      my ($offset, $start, $end, $multiply) = ($2, $3, $4, $6);
      $offset   = 0 unless defined($offset);
      $multiply = 1 unless defined($multiply);
      my @colindexes = map { $offset + $_ * $multiply } $start..$end;
      for (@colindexes) {
         push @::output_nm, $_;
      }
    }
    else {
      $spec = urldecode($spec);
      if ($spec =~ /[$REGEXP_CHARS]/ && $B_regex) {
        my @matches = grep { $_ =~ qr/$spec/ } @::HEADER;
        my $n_matches = @matches; local $" = ' ';
print STDERR "-- (output) expanding pattern $spec ($n_matches matches: @matches)\n" if $B_verbose || !$n_matches;
        for my $m (@matches) {
          push @::output_nm, $m;
        }
      }
      else {
         push @::output_nm, $spec;
      }
    }
  }

  @::output_nm = sort { $a <=> $b } keys %{{ map { ($_, 1) } @::output_nm }} if $B_ko;

  $::plain_handle{$_} = 1 for @::output_nm;

local $" = ',';
print STDERR "-- output column names as specified: [@::output_nm]\n" if $B_debug;
  if ($B_excise || $B_printall) {
    my @new_names = grep { !defined($inheader{$_}) } @::output_nm;
    if ($B_excise) {
       @::output_nm = grep { !defined($::plain_handle{$_}) } @::HEADER
    }
    else {
       @::output_nm = @::HEADER;
    }
    if (defined($INSERT_OFFSET)) {
      $INSERT_OFFSET = @::output_nm if $INSERT_OFFSET > @::output_nm;
      $INSERT_OFFSET = -1 * @::output_nm if $INSERT_OFFSET < -1 * @::output_nm;
      splice @::output_nm, $INSERT_OFFSET, 0, @new_names;
    }
    else {
       push @::output_nm, @new_names;
    }
  }
print STDERR "-- output column names after -i/-a treatment: @::output_nm\n" if $B_debug && ($B_excise || $B_printall);

  if ($B_print_header) {
    my %names = (); my $i = 1;
    for (@::output_nm) { $names{$_} = $i++ unless defined($names{$_}) }
    if (keys %names < @::output_nm) {
       my $job = $B_force ? 'leaving as specified' : 'will make unique';
print STDERR "-- Identical output column names exist ($job)\n";
       @::output_nm = sort { $names{$a} <=> $names{$b} } keys %names unless $B_force;
    }
  }

  #
  ##  Add derived column names to @::HEADER
  ##  Expand regex specifications if found.
  ##  In derived column specs replace names by offsets into field array.
  #

  for (my $i=0; $i<@::compute; $i++) {
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name already defined (use -i for in-place change)\n" if defined($::handle_map{$name}) && !$B_inplace;
    my @expanded_compute = ();
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE && $B_regex  && $what =~ /[$REGEXP_CHARS]/) {
         my @matches = grep { $_ =~ qr/$what/ } @::HEADER;
         my $n_matches = @matches;
         local $" = ' ';
print STDERR "-- (compute) expanding pattern $what ($n_matches matches: @matches)\n" if $B_verbose || !$n_matches;
         for my $h (@matches) {
           push @expanded_compute, [$TYPE_HANDLE, $h];
         }
      }
      else {
         push @expanded_compute, $comp;
      }
    }
    for my $comp (@expanded_compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         die "Handle $what in compute $name does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};     # fixme overwrite inelegant
                              # inplace NOTE. when using foo::foo^1,add, this maps the lookup for the second foo to the offset
                              # for the current foo, and the second foo no longer exists. The first foo does not have an
                              # associated offset yet;
      }
    }
    $::compute[$i] = [$name, \@expanded_compute];

    my $j = $::N + $i;
    $::HEADER[$j] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $j;
                              # inplace NOTE continued. Future lookups for foo will refer to this definition; This includes output.
                              # This process is consistently applied if multiple foo:: are specified.
print STDERR "-- map compute name [$name] to offset $j\n" if $B_debug;
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle $name in output does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "-- output columns @::output_os --\n" if $B_debug;

  #
  ##  In select list replace names by offsets into field array.
  #

  for my $sel (@::select) {

    my ($op, $indirection, $val, $name, $arg) = @$sel;

    die "Handle $name in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});

    my $opdef = $sel_opdefinitions{$op};
    die "The impossible happened ($op)\n" unless defined($opdef);
    $sel->[0] = $opdef->[1];             # fixme overwrite inelegant

    $sel->[3] = $::handle_map{$name};    # fixme overwrite inelegant
    if ($indirection) {
       die "Handle $val in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$val});
       $sel->[2] = $::handle_map{$val};  # fixme overwrite inelegant
    }
    { my ($code, $indirection, $val, $name, $arg) = @$sel;
print STDERR "-- select code=$code ind=$indirection val=$val name=$name arg=$arg --\n" if $B_debug; }

  }

  for (@::HEADER) {
    $_ = '' if $_ eq '_';
  }
}


sub do_compute {

  my $F = shift;

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    @::STACK = ();

    for my $comp (@$compute) {

      my ($type, $what, @other) = @$comp;

         if ($type == $TYPE_HANDLE) { push @::STACK, $F->[$what]; }
      elsif ($type == $TYPE_SCALAR) { push @::STACK, $what; }
      elsif ($type != $TYPE_OPATOR) { die "Really unfortunate!\n"; }

      else {
         my ($n_wanted, $code) = @other;
         die "Stack underflow ($spic->[0] item [$what])\n" unless @::STACK >= $n_wanted;
         &{$code};
         pop @::STACK while --$n_wanted > 0;
      }
    }
    push @$F, (join "", @::STACK);
  }
  die "Cp error\n" unless @::HEADER == @$F;
}


 $::Nrows = 0;    # includes header.
my $Nignr = 0;
my $Ndisc = 0;
my $Nkeep = 0;


while (<>) {

  %::LINECACHE = ();

  if ($M_ignore && /$PAT_IGNORE/) {
    print "$_" if $M_ignore == 2;
    $Nignr++;
    next;
  }

  chomp;
  my @F = length($_) ? split "\t", $_, $OFFSET_OMEGA : ("");

  if ($OFFSET_OMEGA > 0 && @F < $OFFSET_OMEGA) {
    push @F, ( ("") x ($OFFSET_OMEGA - @F)) ;
  }
  if (!$::Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    if (@::nameslist) {
      local $" = ' ';
      die "New names [@::nameslist] and data names [@::HEADER] differ in cardinality" if scalar @::nameslist != scalar @::HEADER;
      @::HEADER = @::nameslist;
    }
    wrangle_header();
    if ($B_print_header || $B_sprouthead) {
      local $, = "\t";
      print map { $::HEADER[$_] } @::output_os;
      $::N_column_output = @::output_os;
      add_column("T") if $B_print_tally;
      print "\n";
    }
    $::Nrows++;
    next unless $B_headless;
  }
  else {
    my $F = @F;
    die "Header/$::N column/$F count difference at line $. (consider -R or -O<N>)" unless $F == $::N;
    $::Nrows++;
  }

  do_compute(\@F);         # this pushes compute onto @F if present.

  my $nmatch = 0;

  if ($B_weirdmode && $::Nrows == 1) {
    $Nkeep++;
  }
  else {
     for my $sel (@::select) {
       my ($op, $indirection, $val, $colid, $arg) = @$sel;
       $val = $F[$val] if $indirection;
       $nmatch++ if $op->($F[$colid], $val, $arg);
         # $arg currently only used for /ep/ and /om/
     }
     if (@::select && (($nmatch != @::select && $B_select_and) || ($nmatch == 0 && !$B_select_and))) {
       $Ndisc++;
       next unless $B_print_tally;
     }
     else {
       $Nkeep++;
     }
  }

  my @outputs = map { $F[$_] } @::output_os;

  local $" = "\t";
  print "@outputs";
  $::N_column_output = @outputs;

  add_column($nmatch) if $B_print_tally;
  print "\n";
}

print STDERR "-- $Nignr ignored lines in input\n" if $M_ignore && $B_verbose;
my $would = $B_print_tally ? ' would' : '';
print STDERR "-- $Nkeep/$Ndisc rows$would have been kept/discarded\n" if @::select && $B_verbose;

my $B_header = 1 - $B_headless;
print STDERR "== Line tally check failed: ($::Nrows != $B_header+$Nkeep+$Ndisc)\n" if $::Nrows != $B_header+$Nkeep+$Ndisc;


__DATA__
                                            s o m e   i d e a s

   -  would --onames be helpful? (note -K)
   ?  options if no map exists
   -  challenge: combine ed and map. replace substring with its map. First ,get it and ,map, then ,ed it.
         not great currently: echo -e "_a_\t3\n_b_\t4" | ./pick -AiK --cdict-foo=a:Alpha,b:Beta x::1^_'(.)'_,get^foo,map 1::1^'(?<=_)(.)(?=_)':x,ed
   -  implement in cimfomfa/C (regular expressions not as good).
   -  get -> option to return field if no match? -> covered by ed; get allows filtering on empty string with uie
   -  -f is useless in the sense that the same name implies the same content.
   ?? +/pat select entire rows on pattern?
   ?  for regex selection, a wildcard tag that allows mass renaming.
   ?  for 'all' operators; store data in internal buffer; storeall.
      minall maxall meanall, medianall, countall sdall can refer to it. needs a scope/clearing framework.
   o  numerical comparisons check field is numeric; however duplicates perl's work/warnings
   ?  predefine constants (e.g. log10, pi). new syntax, e.g. ^^PI ^^LOG10 ^^E ^^PHI - no real need.
   #  -T pushes column; slightly inelegant but inevitable. -N -L fixed as rowno lineno operators.
   ?? ifelse(selectname,compute1,compute2) is beyond scope for now.
      -> foo::,LD:a:b:c,LR,add         # open/close data
         foo::,LC:a:b:c,op,op,RC       # open/close code
         encode scope in a separate datastructure; fast path if no scopes exist.
   -  tests

     ####        ####
    ##   #      #   ##
   #                  #
  ##                  ##
  ##     R. I. P.     ##
   ##                ##
    ##    recol     ##
     ##            ##
       ##        ##
         #      #

