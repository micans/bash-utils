#!/usr/bin/perl

       ##                                                                               ##
      ##      Pick columns and select rows from tabular input, add derived columns       ##
     ##                 Pick and select either by column name or index                    ##
    ##   Select with numerical and string comparison operators and regular expressions     ##
    ##                Select on either existing columns or derived columns                 ##
     ##            Compute derived columns with string and algebraic operations           ##
      ##                      Requires tab separated input                               ##
       ##                See -H (EOH below) and -l (brief help)                         ##

                                      use strict;
                                     use warnings;
@::spec = @ARGV; @ARGV = ();

@::output_nm  = ();         # names - (header|1..N) + compute handles
@::output_os  = ();         # names translated to offsets in @F (field array)
@::compute = ();            # derived column specifications
@::select  = ();            # row select specifications
%::handle_map = ();         # map column names to offsets

my $CMT = '#';              # ::/my style is somewhat intractable.

my $B_print_header = 1;     # B_oolean
my $B_select_and   = 1;     # Require all selections to match (use -o for any)
my $B_print_rowname = 0;    # cannot combine with $B_headless.
my $B_print_tally  = 0;     # Print trailing T column with count of selections matched
my $B_print_lineno = 0;     # Do it
my $B_print_rowno  = 0;     # Just do it
my $B_printall     = 0;     # Select all columns
my $B_inplace      = 0;     # Allow derived column to redefine existing column name
my $B_excise       = 0;     # print all except the plain column handles listed, cannot combine with $B_printall
my $B_add_row_column = 0;   # See -H, EOH
my $B_headless     = 0;     # No header (-k option)
my $B_weirdmode    = 0;     # Header exists, but users wants to use numbers (turns of selections for header)
my $B_force        = 0;     # Force output if identical output names exist
my $M_comment      = 0;     # M_ode: 0 oblivious, 1 strip, 2 pass
my $B_debug        = 0;     # Mostly documents the stages of compute and selection definitions
my $B_verbose      = 0;     # Not terrifically interesting

$::EPSILON         = 0.0001;  # obvs the best default epsilon - 10,000 is a myriad.
$::OOM             = 2;     # order of magnitude. Maybe sqrt(2) makes more sense.

sub stacky { die "$_[0] stack error\n" unless @::STACK >= $_[1]; }

my %cp_opdefinitions =
   ( add       => [ 2, sub { $::STACK[-2] += $::STACK[-1] } ],
     mul       => [ 2, sub { $::STACK[-2] *= $::STACK[-1] } ],
     div       => [ 2, sub { $::STACK[-2] /= $::STACK[-1] } ],
     cat       => [ 2, sub { $::STACK[-2] .= $::STACK[-1] } ],
     sub       => [ 2, sub { $::STACK[-2] -= $::STACK[-1] } ],
     pop       => [ 0, sub { stacky('pop', 1); pop @::STACK } ],
     dup       => [ 0, sub { stacky('dup', 1); push @::STACK, $::STACK[-1]  } ],
     xch       => [ 0, sub { stacky('xch', 2); ($::STACK[-2], $::STACK[-1]) = ($::STACK[-1], $::STACK[-2]) } ],
     mod       => [ 2, sub { $::STACK[-2] %= $::STACK[-1] } ],
     pow       => [ 2, sub { $::STACK[-2] **= $::STACK[-1] } ],
     and       => [ 2, sub { $::STACK[-2] &= $::STACK[-1] } ],
     or        => [ 2, sub { $::STACK[-2] |= $::STACK[-1] } ],
     xor       => [ 2, sub { $::STACK[-2] ^= $::STACK[-1] } ],
     max       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] > $::STACK[-2] } ],
     min       => [ 2, sub { $::STACK[-2] = $::STACK[-1] if $::STACK[-1] < $::STACK[-2] } ],
     # rep       => [ 2, sub { $::STACK[-2] = $::STACK[-2] x $::STACK[-1] } ],

     get       => [ 2, sub { my $item =  $::STACK[-2] =~ /$::STACK[-1]/
                                         ? (defined($1) ? $1 : $&) : ""; $::STACK[-2] = $item; } ],

     ed        => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/  } ],
     edg       => [ 3, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/g } ],

     uc        => [ 1, sub { $::STACK[-1] = uc($::STACK[-1]) }         ],
     lc        => [ 1, sub { $::STACK[-1] = lc($::STACK[-1]) }         ],
     rev       => [ 1, sub { $::STACK[-1] = reverse($::STACK[-1]) }    ],
     rot13     => [ 1, sub { $::STACK[-1] =~ tr/a-zA-Z/n-za-mN-ZA-M/ } ],
     len       => [ 1, sub { $::STACK[-1] = length($::STACK[-1]) }     ],
     rc        => [ 1, sub { $::STACK[-1] =~ tr/acgtuACGTU/tgcaaTGCAA/; $::STACK[-1] = reverse($::STACK[-1]) } ],
     abs       => [ 1, sub { $::STACK[-1] = abs($::STACK[-1]) }        ],
     sqrt      => [ 1, sub { $::STACK[-1] = sqrt($::STACK[-1]) }       ],
     sq        => [ 1, sub { $::STACK[-1] = $::STACK[-1]**2 }          ],
     exp       => [ 1, sub { $::STACK[-1] = exp($::STACK[-1]) }        ],
     cos       => [ 1, sub { $::STACK[-1] = cos($::STACK[-1]) }        ],
     sin       => [ 1, sub { $::STACK[-1] = sin($::STACK[-1]) }        ],
     tan       => [ 1, sub { $::STACK[-1] = sin($::STACK[-1])/cos($::STACK[-1]) } ],
     log       => [ 1, sub { $::STACK[-1] = log($::STACK[-1]) }        ],
     log10     => [ 1, sub { $::STACK[-1] = log($::STACK[-1])/log(10) }],
     exp10     => [ 1, sub { $::STACK[-1] = 10**$::STACK[-1] }         ],
     sign      => [ 1, sub { $::STACK[-1] = $::STACK[-1] > 0 ? 1 : $::STACK[-1] < 0 ? -1 : 0 } ],
   );

            # sub { } :
            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
            # For /ep/ and /om/ third argument is $::EPSILON/$::OOM or specified suffix.
            # 40 41 etc just to keep sort order when outputting list of select ops,
            # as '/' is overloaded in a slightly confusing way (negation and num op delimiter),
            # as is '~' (matching and string op delimiter). This keeps them grouped together.
            #
my %sel_opdefinitions = (
  '~'          => [ 40, sub { $_[0] =~ /$_[1]/ } ],
  '/~'         => [ 41, sub { $_[0] !~ /$_[1]/ } ],
  '='          => [ 42, sub { $_[0]  eq $_[1]  } ],
  '/='         => [ 43, sub { $_[0]  ne $_[1]  } ],

  '/eq/'       => [ 44, sub { $_[0] == $_[1] } ],
  '/ne/'       => [ 45, sub { $_[0] != $_[1] } ],
  '/lt/'       => [ 46, sub { $_[0] <  $_[1] } ],
  '/le/'       => [ 47, sub { $_[0] <= $_[1] } ],
  '/ge/'       => [ 48, sub { $_[0] >= $_[1] } ],
  '/gt/'       => [ 49, sub { $_[0] >  $_[1] } ],

  '/ep/'       => [ 50, sub { interval_plus(@_)} ],
  '/om/'       => [ 51, sub { interval_mul(@_) } ],

  '~eq~'       => [ 52, sub { $_[0] eq $_[1] } ],
  '~ne~'       => [ 53, sub { $_[0] ne $_[1] } ],
  '~lt~'       => [ 54, sub { $_[0] lt $_[1] } ],
  '~le~'       => [ 55, sub { $_[0] le $_[1] } ],
  '~ge~'       => [ 56, sub { $_[0] ge $_[1] } ],
  '~gt~'       => [ 57, sub { $_[0] gt $_[1] } ],

     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/'      => [ 58, sub { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) } ],
  '/any/'      => [ 59, sub { abs(int($_[0])) & abs(int($_[1])) } ],
  '/none/'     => [ 60, sub { ! (abs(int($_[0])) & abs(int($_[1]))) } ]

);

my $help_options=q{Options:
  -k headerless input, use 1 2 .. for column names (see also -K below)
  -h do not print header
  -o OR multiple criteria (default is AND)
  -x take complement of selected input column(s) (works with -i)
  -c strip lines starting with the comment sign (cf -/ option)
  -C pass lines starting with the comment sign unchanged (cf -/ option)
  -i in-place: <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -z print miscellaneous information, e.g. url encoding hex codes
  -/<str> treat <str> at beginning of line as comment line, e.g. -/@ for sam files (implies -c)
  -v verbose

  -A print all input columns (selecting by colspec applies, -T accepted)
  -T do not select, print tally column of count of matched row select criteria (name T)
  -L print file line number column (name L)
  -N print table row number column (name N)

  -r print rownames if row name field in header is the empty string.
    in this case _ is the name to select with <op> on rownames.
  -R add _ column if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically.
  -f force output (overrides identical output columns)
  -K (weird mode) header exists but use 1 2 .. for column names (selection not applied to header)

  options can be combined, use e.g. -ok/@ for headerless input, comment lines indicated by @
  and selects OR selection.
  -AT is useful for inspecting/checking select criteria
  use -Ai <name>::<COMPUTE> to change column <name> to <COMPUTE>,
  use -Aik <num>::<COMPUTE> to change column <num> to <COMPUTE>.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (column name, index, or derived compute name)
  (2) @<HANDLE><op><VAL>       select criterion compare handle to constant value with <op>
  (3) @<HANDLE><op>:<HANDLE2>  select criterion compare handle to other handle with <op>
  (4) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output};

my @ops0 = sort grep { $cp_opdefinitions{$_}[0] == 0 } keys %cp_opdefinitions;
my @ops1 = sort grep { $cp_opdefinitions{$_}[0] == 1 } keys %cp_opdefinitions;
my @ops2 = sort grep { $cp_opdefinitions{$_}[0] == 2 } keys %cp_opdefinitions;
my @ops3 = sort grep { $cp_opdefinitions{$_}[0] == 3 } keys %cp_opdefinitions;
# selectops
my @opsf = sort { $sel_opdefinitions{$a}[0] <=> $sel_opdefinitions{$b}[0] } keys %sel_opdefinitions;

while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;
  ($CMT, $M_comment) = ($1, 1) if $options =~ s/\/(.*)$//;
  $B_print_header = 0 if $options =~ /h/;
  $B_select_and   = 0 if $options =~ /o/;
  $B_verbose      = 1 if $options =~ /v/;
  $B_print_rowname= 1 if $options =~ /r/;
  $B_print_tally  = 1 if $options =~ /T/;
  $B_print_lineno = 1 if $options =~ /L/;
  $B_print_rowno  = 1 if $options =~ /N/;
  $B_printall     = 1 if $options =~ /A/;
  $B_excise       = 1 if $options =~ /x/;
  $B_add_row_column =1 if $options =~ /R/;
  $B_headless     = 1 if $options =~ /k/;
  ($B_headless, $B_weirdmode) = (1, 1) if $options =~ /K/;
  $B_debug        = 1 if $options =~ /d/;
  $B_force        = 1 if $options =~ /f/;
  $B_inplace      = 1 if $options =~ /i/;
  $M_comment      = 1 if $options =~ /c/;
  $M_comment      = 2 if $options =~ /C/;

  if ($options =~ /z/) {
    my @trickylist = split "", q{ %:^,!@#$&*(){}[]<>.;`"'|?-_+=~/\\};
    my @trickyenc  = map { sprintf("%02X", ord($_)) } @trickylist;
    my $t1 = join "  ", @trickylist;
    my $t2 = join " ",  @trickyenc;
    print "$t1\n$t2\n";
    exit 0;
  }
  elsif ($options =~ /l/) {
    print $help_options, "\n";
    print "\nSelect/compute forms:$spec_forms\n";
    print "\nOperators for compute:\n";
    print "  Stack control: @ops0\n";
    print "  Take 1: @ops1\n";
    print "  Take 2: @ops2\n";
    print "  Take 3: @ops3\n";
    print "\nSelect comparison operators:\n";
    print "  @opsf\n";
    print "\nCOMPUTE: <part>+ where <part> is one of ^<value> :<handle> ,<operator>\n";
    print "\nSee -H for longer descriptions.\n";
    exit 0;
  }
  elsif ($options =~ /H/) {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
See further below for <op> list.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a select criterion comparing a handle to a constant value. 
Form (3) creates a select criterion comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op>[^]<VAL>
@<COLNAME><op>:<COLNAME>
selects rows based on <VAL> or value in column <COLNAME>; see list below for <op>.
Colon introduces a column name; <VAL> is url-decoded; a leading ^ is removed.
<op> is one of the following:
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/<what>/epsilon  Aproximate numerical identity wrt <what> +- epsilon
  /om/<what>/oom      Aproximate magnitude identity wrt |<what>| * oom
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> will be url-decoded. In particular, if you need one of [%^:,/~]
  in <string> it is best to url-encode it with 25, 5E, 3A, 2C, 2F, 7E respectively.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).  <op> is one of

  Stack control: @ops0
  Take 1 | @ops1
  Take 2 | @ops2
  Take 3 | @ops3

  If the very first part starts with anything other than [,:^] it is inferred
  to be a handle (leading : not needed).  <COMPUTE> is a stack, so
  zut::foo:bar,add^str,cat creates a new column called zut by adding columns
  foo and bar and then concatenating 'str'. The default operation is
  concatenation; if no operators are left the remainder of the stack is
  concatenated. Thus the above is equivalent to zut::foo:bar,add^str. To just
  prefix a column: zut::^foo:zut To concatenate two columns: zut::foo:bar .
  Below: get, ed and edg examples.

   :handle^str1,get      =>  handle =~ s/str1/MATCH/
   :handle^str1^str2,ed  =>  handle =~ s/str1/str2/ 
   :handle^str1^str2,edg =>  handle =~ s/str1/str2/g

  MATCH refers to () if present in str1, matched part otherwise.
  str1 accepts most/all perl regular expression syntax.
EOH
  exit 0;
  }
}

die "-a -x do not combine\n" if $B_printall && $B_excise;
die "-r -k do not combine\n" if $B_print_rowname && $B_headless;
$B_print_header = 0 if $B_headless;

# die "Need something (use -l for short help, -H for longer description)\n" unless @::spec || $B_printall;
# Turns out we don't need anything. pick -NLT < abc works, for example. Or even pick < abc.

sub interval_plus {
  my ($x, $y, $val) = @_;
  my $epsilon = $val ? $val : $::EPSILON;
  return $x <= $y + $epsilon && $x >= $y - $epsilon;
}

sub interval_mul {
  my ($x, $y, $val) = @_;
  my $oom = $val ? $val : $::OOM;
  return abs($x) <= abs($y) * $oom && abs($x) >= abs($y) / $oom;
}


my $TYPE_SCALAR = 1;
my $TYPE_HANDLE = 2;
my $TYPE_OPATOR = 3;    # (1) rule of six obvs, (2) it makes sense in Dutch.

my %chartypetonum = ( '^', $TYPE_SCALAR, ':', $TYPE_HANDLE, ',', $TYPE_OPATOR );

sub parse_stack {
  my ($handle, $spec) = @_;
  my @oplist = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[\/^:]/;
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]+)/g) {
    my ($type, $what) = ($chartypetonum{$1}, $2);
    $what = urldecode($what) if $type == $TYPE_SCALAR;
    push @oplist, [$type, $what];
    $p = pos($spec);
    if ($type == $TYPE_OPATOR) {
      my $opdef = $cp_opdefinitions{$what};
      die "Not supported [$what]\n" unless defined($opdef);
                           # N stack required, code.
      push @{$oplist[-1]}, ($opdef->[0], $opdef->[1]);
print STDERR "-- $handle >> type=$type op=$what N=$opdef->[0], code=$opdef->[1]\n" if $B_debug;
    }
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oplist;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


for my $spec (@::spec) {
     # fixme: ':=' or '::' cannot occur in handle in compute. url-decoding handle can remedy that.
  if ($spec =~ /(.*?)(:[:=])(.*)/) {
    my ($handle, $type, $compute) = ($1, $2, $3);
    my $stack = parse_stack($handle, $compute);
    push @::compute, [$handle, $stack];
    push @::output_nm, $handle if $type eq '::';
  }
                #  H handle
                #  a1a2a3, b, c, d different forms for op
                #  V value or :handle
                #    ( H )([ a1](      a2    )[ a3]|  b    | c | d )( V)(  arg )
  elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~]|[=~]{1}|\/=|\/~)(.*?)(\/.*?)?$/) {
    my ($handle, $op, $val, $arg) = ($1, $2, $3, $4);
    die "Unrecognised operator [$op]\n" unless defined($sel_opdefinitions{$op});
    if (defined($arg)) {
      die "Extra argument currently only allowed for /ep/ and /om/" unless $op =~ /^\/(ep|om)\/$/;
    }
    else{
       $arg = 0;
    }
    $arg =~ s|^/||;
print STDERR "-- adding select criterion handle=[$handle] op=[$op] val=[$val] arg=[$arg]\n" if $B_debug;
    my $indirection = 0;
    if ($val =~ s/^://) {
      $indirection = 1;
    }
    else {
      $val = urldecode($val);
    }
                # NOTE. $arg for now only used by /ep/ and /om/ selection, ignored by the others.
    push @::select, [$op, $indirection, $val, $handle, $arg];
  }
  else {
    push @::output_nm, $spec;
  }
}

sub add_column {
  print "\t" if $::N_column_output++; print $_[0];
}

sub wrangle_header {

  if ($::HEADER[0] eq '') { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_' }

  $::N = @::HEADER;
  my %inheader = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name});
    $::handle_map{$name} = $i;   
    print STDERR "-- map header name $name to offset $i\n" if $B_debug;
  }

  print STDERR "-- output column names as specified: @::output_nm\n" if $B_debug;
  if ($B_excise) {         # note excise we end up with input order.
    my %excise = map { ($_, 1) } @::output_nm;
    @::output_nm = ((grep { !defined($excise{$_}) } @::HEADER), (grep { !defined($inheader{$_}) } @::output_nm));
  }
  elsif ($B_printall) {
    print STDERR "-- adding columns @::output_nm to header names\n" if @::output_nm && $B_debug;
    @::output_nm = (@::HEADER, grep { !defined($inheader{$_}) } @::output_nm);
  }
  print STDERR "-- output column names after -i/-a treatment: @::output_nm\n" if $B_debug && ($B_excise || $B_printall);

  if ($B_print_header && keys %{{ map { ($_, 1) } @::output_nm }} < @::output_nm) {
    my $job = $B_force ? 'continuing' : 'fatal, use -f to force';
    print STDERR "-- Identical output column names exist ($job)\n";
    exit 1 unless $B_force;
  }

  #
  ##  Add derived column names to @::HEADER
  ##  In derived column specs replace names by offsets into field array.
  #

  for (my $i=0; $i<@::compute; $i++) {
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name already defined (use -i for in-place change)\n" if defined($::handle_map{$name}) && !$B_inplace;
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         die "Handle $what in compute $name does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};     # fixme overwrite inelegant
      }
    }
    my $j = $::N + $i;
    $::HEADER[$j] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $j;
    print STDERR "-- map compute name $name to offset $j\n" if $B_debug;
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle $name in output does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "-- output columns @::output_os --\n" if $B_debug;

  #
  ##  In select list replace names by offsets into field array.
  #

  for my $sel (@::select) {

    my ($op, $indirection, $val, $name, $arg) = @$sel;

    die "Handle $name in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$name});

    my $opdef = $sel_opdefinitions{$op};
    die "The impossible happened ($op)\n" unless defined($opdef);
    $sel->[0] = $opdef->[1];             # fixme overwrite inelegant

    $sel->[3] = $::handle_map{$name};    # fixme overwrite inelegant
    if ($indirection) {
       die "Handle $val in select does not reference a known entity among @::HEADER\n" unless defined($::handle_map{$val});
       $sel->[2] = $::handle_map{$val};  # fixme overwrite inelegant
    }
    { my ($code, $indirection, $val, $name, $arg) = @$sel;
print STDERR "-- select code=$code ind=$indirection val=$val name=$name arg=$arg --\n" if $B_debug; }

  }
}


sub do_compute {

  my $F = shift;

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    @::STACK = ();

    for my $comp (@$compute) {

      my ($type, $what, @other) = @$comp;

         if ($type == $TYPE_HANDLE) { push @::STACK, $F->[$what]; }
      elsif ($type == $TYPE_SCALAR) { push @::STACK, $what; }
      elsif ($type != $TYPE_OPATOR) { die "Really unfortunate!\n"; }

      else {
         my ($n_wanted, $code) = @other;
         die "Stack underflow ($spic->[0] item [$what])\n" unless @::STACK >= $n_wanted;
         &{$code};
         pop @::STACK while --$n_wanted > 0;
      }
    }
    push @$F, (join "", @::STACK);
  }
  die "Cp error\n" unless @::HEADER == @$F;
}


my $Nrows = 0;    # includes header.
my $Ncmts = 0;
my $Ndisc = 0;
my $Nkeep = 0;

while (<>) {

  if ($M_comment && /^$CMT/) {
    print "$_" if $M_comment == 2;
    $Ncmts++;
    next;
  }

  chomp;
  my @F = split "\t", $_, -1;
  my $rowname = undef;

  if (!$Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    wrangle_header();
    if ($B_print_header) {
      local $, = "\t";
      print map { $::HEADER[$_] } @::output_os;
      $::N_column_output = @::output_os;
      add_column("N") if $B_print_rowno;
      add_column("L") if $B_print_lineno;
      add_column("T") if $B_print_tally;
      print "\n";
    }
    $Nrows++;
    next unless $B_headless;
  }
  else {
    $Nrows++;
  }

  if (!$B_headless && $::N+1 == @F) {
    print STDERR "-- adjusting for header row count discrepancy ($::N)\n" if $B_verbose && $Nrows == 2;
    if ($Nrows == 2)              { $::B_extra_rownames = 1; }
    elsif (!$::B_extra_rownames)  { die "Row count inconsistency line $.\n"; }
    $rowname = shift @F;
  }
  elsif ($::B_extra_rownames || $::N != @F) {
    die "Row count inconsistency at line $.\n";
  }

  do_compute(\@F);         # this pushes compute onto @F if present.

  my $nmatch = 0;

  if ($B_weirdmode && $Nrows == 1) {
    $Nkeep++;
  }
  else {
     for my $sel (@::select) {
       my ($op, $indirection, $val, $colid, $arg) = @$sel;
       $val = $F[$val] if $indirection;
       $nmatch++ if $op->($F[$colid], $val, $arg);
         # $arg currently only used for /ep/ and /om/
     }
     if (@::select && (($nmatch != @::select && $B_select_and) || ($nmatch == 0 && !$B_select_and))) {
       $Ndisc++;
       next unless $B_print_tally;
     }
     else {
       $Nkeep++;
     }
  }

  print "$rowname\t" if defined($rowname) && $B_print_rowname;
  my @outputs = map { $F[$_] } @::output_os;

  local $" = "\t";
  print "@outputs";
  $::N_column_output = @outputs;

  add_column($Nrows-1+$B_headless)  if $B_print_rowno;
  add_column($.)      if $B_print_lineno;
  add_column($nmatch) if $B_print_tally;
  print "\n";
}

print STDERR "-- $Ncmts comment lines in input\n" if $M_comment && $B_verbose;
my $would = $B_print_tally ? ' would' : '';
print STDERR "-- $Nkeep/$Ndisc rows$would have been kept/discarded\n" if @::select && $B_verbose;

my $B_header = 1 - $B_headless;
print STDERR "== Line tally check failed: ($Nrows != $B_header+$Nkeep+$Ndisc)\n" if $Nrows != $B_header+$Nkeep+$Ndisc;



       ####        ####
      ##   #      #   ##
     #                  #
    ##                  ##
    ##     R. I. P.     ##
     ##                ##
      ##    recol     ##
       ##            ##
         ##        ##
           #      #


__DATA__

   s o m e   i d e a s
   -  catch divide by zero before it happens.
   -  variations for -/CMT; -//CMT anywhere; -///pat select on pattern
   -  predefine constants (e.g. log10, pi). new syntax, e.g. ^^PI ^^LOG10 ^^E ^^PHI ?
      written row/column index: ^^ROW ^^ROW0 ^^COLUMN ^^COLUMN0.
   -? descriptions of operators
   -  implement in Python.
   -  implement in cimfomfa/C.
   ?  -s short-circuit selecting: in and-selecting bail out after first fail
      -> can help prevent failing later select criterions in heterogeneous data.
      -> heterogeneous data better served with -/// selection
   -  clearly define all interactions between -A, -i, -x, -f
   -  operators to validate column type (integer, regex) .. half-exists already.
   #  rep is a lot of (memory) rope. Some warning/protection/override mechanism?
   -  tests
   ?? ifelse(selectname,compute1,compute2) is beyond scope for now.
      -> o and c operators to delimit blocks, could become quite fiendish.
         ^filtname,o....,c,o......c,ifelse, c would know how many things below it until o.
   ?  numerical comparisons check field is numeric
