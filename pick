#!/usr/bin/perl

       ##                                                                               ##
      ##      Pick columns and filter rows from tabular input, add derived columns       ##
     ##                 Pick and filter either by column name or index                    ##
    ##   Filter with numerical and string comparison operators and regular expressions.    ##
    ##                Filter on either existing columns or derived columns.                ##
     ##            Compute derived columns with string and algebraic operations.          ##
      ##                      Requires tab separated input.                              ##
       ##                See -H (EOH below) and -l (brief help)                         ##

                                      use strict;
                                     use warnings;

@::spec = @ARGV; @ARGV = ();
@::output_nm  = ();         # names - (header|1..N) + handles
@::output_os  = ();         # names translated to offsets
@::compute = ();
@::filter  = ();

%::handle_map = ();

my $CMT = '#';

my $B_print_header = 1;
my $B_filter_and   = 1;
my $B_print_rowname = 0;    # cannot combine with $B_headless.
my $B_print_tally  = 0;
my $B_printall     = 0;
my $B_inplace      = 0;
my $B_excise       = 0;     # print all except unadorned columns listed, cannot combine with $B_printall
my $B_add_row_column = 0;
my $B_headless     = 0;
my $B_debug        = 0;
my $B_force        = 0;
my $M_comment      = 0;     # 0 oblivious, 1 strip, 2 pass

BEGIN {
  $::EPSILON = 0.0001; $::EPSILON = $ENV{EPSILON} if defined($ENV{EPSILON});
  $::OOM     = 2; $::OOM     = $ENV{OOM} if defined($ENV{OOM});
}

my $help_options=q{Options:
  -i in-place: all columns are output, <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -k headerless input, use 1 2 .. for column names
  -a print all input columns (filtering by colspec applies, -t accepted)
  -h do not print header
  -t print final tally column of count of matched column filters
  -v OR multiple criteria (default is AND)
  -x take complement of selected input column(s) (works with -i)
  -r print rownames if no column name for rownames exists;
    in this case _ is the name to select with <op> on rownames.
  -R add _ column if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically.
  -c strip lines starting with #
  -C pass lines starting with # unchanged
  -f force output (overrides identical output columns)
  -z print miscellaneous information, e.g. url encoding hex codes
  -/<str> treat <str> at beginning of line as comment line, e.g. -/@ for sam files

  -at is useful for inspecting/checking filters
  options can be combined, use e.g. -kc/@ for headerless input,
  comment lines indicated by @.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (either column or derived compute name)
  (2) @<HANDLE><op><VAL>       filter criterion compare handle to constant value
  (3) @<HANDLE><op>:<HANDLE2>  filter criterion compare handle to other handle
  (4) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output};


while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;
  $B_print_header = 0 if $options =~ /h/;
  $B_filter_and   = 0 if $options =~ /v/;
  $B_print_rowname= 1 if $options =~ /r/;
  $B_print_tally  = 1 if $options =~ /t/;
  $B_printall     = 1 if $options =~ /a/;
  $B_excise       = 1 if $options =~ /x/;
  $B_add_row_column =1 if $options =~ /R/;
  $B_headless     = 1 if $options =~ /k/;
  $B_debug        = 1 if $options =~ /d/;
  $B_force        = 1 if $options =~ /f/;
  $B_inplace      = 1 if $options =~ /i/;
  $M_comment      = 1 if $options =~ /c/;
  $M_comment      = 2 if $options =~ /C/;
  $CMT = $1 if $options =~ /\/(.*)/;

  if ($options =~ /z/) {
    my @trickylist = split "", q{ <>!:;$%&`"'|(){}[]?*^-_+=@~/\#.,};
    my @trickyenc  = map { sprintf("%02X", ord($_)) } @trickylist;
    my $t1 = join "  ", @trickylist;
    my $t2 = join " ",  @trickyenc;
    print "$t1\n$t2\n";
    exit 0;
  }
  elsif ($options =~ /l/) {
    print $help_options, "\n";
    print "\nSelect/filter/compute forms:$spec_forms\n";
    print "See -H for longer description\n";
    exit 0;
  }
  elsif ($options =~ /H/) {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
  See further below.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a filter comparing a handle to a constant value. 
Form (3) creates a filter comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op>[^]<VAL>
@<COLNAME><op>:<COLNAME>
selects rows based on <VAL> or value in column <COLNAME>; see list below for <op>.
Colon introduces a column name; <VAL> is url-decoded; a leading ^ is removed.
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/  Aproximate numerical identity wrt VAL +- EPSILON; export variable EPSILON (current value $::EPSILON)
  /om/  Aproximate numerical identity wrt VAL * OOM, VAL / OOM (current value $::OOM, not sign aware)
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> will be url-decoded. In particular, if you need one of [%^:,]
  in <string> it is best to url-encode it with 25, 5E, 3A, 2C respectively.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).  <op> is one of
    
    / add sub mul div get
    \\ mod cat           (consume two   leave one)
    ed edg              (consume three leave one)       edit, edit global
    uc lc rot13 len rc  (consume one   leave one)       upper case, lower case, rot13, length, revcompl

  If the very first part starts anything other than [,:^] it is inferred to be a handle
  (leading : not needed).  <COMPUTE> is a stack, so zut::foo:bar,add^str,cat
  creates a new column called zut by adding columns foo and bar and then
  concatenating 'str'. The default operation is concatenation; if no operators
  are left the remainder of the stack is concatenated. Thus the above is
  equivalent to zut::foo:bar,add^str. To just prefix a column: zut::^foo:zut
  To concatenate two columns: zut::foo:bar . Below: get, ed and edg examples.

   :handle^str1,get      =>  handle =~ s/str1/MATCH/    # MATCH refers to () if present in str1, matched part otherwise.
   :handle^str1^str2,ed  =>  handle =~ s/str1/str2/     # str1 accepts most/all perl regular expression syntax.
   :handle^str1^str2,edg =>  handle =~ s/str1/str2/g    # str1 accepts most/all perl regular expression syntax.
EOH
  exit 0;
  }
}

die "-a -x do not combine\n" if $B_printall && $B_excise;
die "-r -k do not combine\n" if $B_print_rowname && $B_headless;
$B_print_header = 0 if $B_headless;

die "Need something (use -l for short help, -H for longer description)\n" unless @::spec || $B_printall;


sub interval_plus {
  my ($x, $y) = @_;
  return $x <= $y + $::EPSILON && $x >= $y - $::EPSILON;
}

sub interval_mul {
  my ($x, $y) = @_;
  return abs($x) <= abs($y) * $::OOM && abs($x) >= abs($y) / $::OOM;
}

            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
my %ops = (
  '~'    => sub { $_[0] =~ /$_[1]/ },
  '/~'   => sub { $_[0] !~ /$_[1]/ },
  '='    => sub { $_[0] eq $_[1] },
  '/='   => sub { $_[0] ne $_[1] },
  '/ep/' => sub { interval_plus(@_) },
  '/om/' => sub { interval_mul(@_) },

  '/eq/' => sub { $_[0] == $_[1] },
  '/ne/' => sub { $_[0] != $_[1] },
  '/lt/' => sub { $_[0] <  $_[1] },
  '/le/' => sub { $_[0] <= $_[1] },
  '/ge/' => sub { $_[0] >= $_[1] },
  '/gt/' => sub { $_[0] >  $_[1] },


     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/' => sub  { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) },
  '/any/'  => sub { abs(int($_[0])) & abs(int($_[1])) },
  '/none/' => sub { ! (abs(int($_[0])) & abs(int($_[1]))) },

  '~eq~' => sub { $_[0] eq $_[1] },
  '~ne~' => sub { $_[0] ne $_[1] },
  '~lt~' => sub { $_[0] lt $_[1] },
  '~le~' => sub { $_[0] le $_[1] },
  '~ge~' => sub { $_[0] ge $_[1] },
  '~gt~' => sub { $_[0] gt $_[1] }
);

my %stackopnarg =
   ( add => 2, mul => 2, div => 2, cat => 2, sub => 2, mod => 2, get => 2,
     ed  => 3, edg => 3,
     uc  => 1, lc => 1, rot13 => 1, len => 1, rc => 1
   );

sub parse_stack {
  my $spec = shift;
  my @oppair = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[\/^:]/;
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]+)/g) {
    my ($type, $what) = ($1, $2);
    $what = urldecode($what) if $type eq '^';
    push @oppair, [$type, $what];
    $p = pos($spec);
    die "Not supported [$what]\n" if $type eq ',' && !defined($stackopnarg{$what});
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oppair;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


for my $spec (@::spec) {
     # fixme: ':=' or '::' cannot occur in handle in compute. url-decoding handle can remedy that.
  if ($spec =~ /(.*?)(:[:=])(.*)/) {
    my ($handle, $type, $compute) = ($1, $2, $3);
    my $stack = parse_stack($compute);
    push @::compute, [$handle, $stack];
    push @::output_nm, $handle if $type eq ':=';
  }
                #  H handle
                #  a1a2a3, b, c, d different forms for op
                #  V value or :handle
                #    ( H )([ a1](      a2    )[ a3]|  b    | c | d )( V)
  elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~]|[=~]{1}|\/=|\/~)(.*)/) {
    my ($handle, $op, $val) = ($1, $2, $3);
    die "Unrecognised operator [$op]\n" unless defined($ops{$op});
    my $indirection = 0;
    if ($val =~ s/^://) {
      $indirection = 1;
    }
    else {
      $val = urldecode($val);
    }
    push @::filter, [$op, $indirection, $val, $handle];
  }
  else {
    push @::output_nm, $spec;
  }
}

sub add_tally {
  print "\t" if @::output_os; print $_[0];
}


sub wrangle_header {

  if ($::HEADER[0] eq '') { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_' }

  $::N = @::HEADER;
  my %inheader = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name});
    $::handle_map{$name} = $i;   
  }

  if ($B_excise) {         # note excise we end up with input order.
    my %excise = map { ($_, 1) } @::output_nm;
    @::output_nm = ((grep { !defined($excise{$_}) } @::HEADER), (grep { !defined($inheader{$_}) } @::output_nm));
  }
  elsif ($B_printall) {
    print STDERR "-- Adding columns @::output_nm to input\n" if @::output_nm && $B_debug;
    @::output_nm = (@::HEADER, @::output_nm);
  }

  if ($B_print_header && keys %{{ map { ($_, 1) } @::output_nm }} < @::output_nm) {
    my $job = $B_force ? 'continuing' : 'fatal, use -f to force';
    print STDERR "-- Identical output column names exist ($job)\n";
    exit 1 unless $B_force;
  }

  #
  ##  Add derived column names to @::HEADER
  ##  In derived column specs replace names by offsets into field array.
  #

  for (my $i=0; $i<@::compute; $i++) {
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name defined more than once\n" if defined($::handle_map{$name}) && !$B_inplace;
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type eq ':') {
         die "Handle $what in compute $name does not reference a known entity\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};
      }
    }
    $::HEADER[$::N+$i] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $::N+$i;
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle $name in output does not reference a known entity\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "-- output columns @::output_os --\n" if $B_debug;

  #
  ##  In filter list replace names by offsets into field array.
  #

  for my $filt (@::filter) {

    my ($op, $indirection, $val, $name) = @$filt;

    die "Handle $name in filter does not reference a known entity\n" unless defined($::handle_map{$name});
    $filt->[3] = $::handle_map{$name};
    if ($indirection) {
       die "Handle $val in filter does not reference a known entity\n" unless defined($::handle_map{$val});
       $filt->[2] = $::handle_map{$val};
    }
print STDERR "-- filter @$filt --\n" if $B_debug;

  }
}


sub do_compute {

  my $F = shift;

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    my @stack = ();
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;

      if ($type eq ':') {
        push @stack, $F->[$what];
      }
      elsif ($type eq '^') {
        push @stack, $what;
      }
      elsif ($type eq ',') {
        my $n_wanted = $stackopnarg{$what};
        die "Stack underflow ($spic->[0])\n" unless @stack >= $n_wanted;
        if ($n_wanted == 2) {
           if ($what eq 'add') { $stack[-2] += $stack[-1] }
        elsif ($what eq 'cat') { $stack[-2] .= $stack[-1] }
        elsif ($what eq 'mul') { $stack[-2] *= $stack[-1] }
        elsif ($what eq 'sub') { $stack[-2] -= $stack[-1] }
        elsif ($what eq 'div') { $stack[-2] /= $stack[-1] }
        elsif ($what eq 'mod') { $stack[-2] %= $stack[-1] }
        elsif ($what eq 'get') { my $item = $stack[-2] =~ /$stack[-1]/ ? (defined ($1) ? $1 : $&) : ""; $stack[-2] = $item; }
           pop @stack;
        }
        elsif ($n_wanted == 1) {
           if ($what eq 'uc') {  $stack[-1] = uc($stack[-1]) }
        elsif ($what eq 'lc') {  $stack[-1] = lc($stack[-1]) }
        elsif ($what eq 'rot13') {  $stack[-1] =~ tr/N-ZA-Mn-za-m/A-Za-z/ }
        elsif ($what eq 'len') {  $stack[-1] = length($stack[-1]) }
        elsif ($what eq 'rc') {  my $x = $stack[-1]; $x =~ tr/acgtACGT/tgcaTGCA/; $stack[-1] = reverse($x) }
        }
        else {
           if ($what eq 'ed')  { $stack[-3] =~ s/$stack[-2]/$stack[-1]/ }
        elsif ($what eq 'edg') { $stack[-3] =~ s/$stack[-2]/$stack[-1]/g }
           pop @stack; pop @stack;
        }
      }
    }
    push @$F, (join "", @stack);
  }
  die "Cp error\n" unless @::HEADER == @$F;
}

my $Nrows = 0;    # includes header.
my $Ncmts = 0;
my $Nfilt = 0;

while (<>) {

  chomp;
  my @F = split "\t", $_, -1;
  my $rowname = undef;

  if ($M_comment && /^$CMT/) {
    print "$_\n" if $M_comment == 2;
    $Ncmts++;
    next;
  }
  elsif (!$Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    wrangle_header();
    if ($B_print_header) {
      local $, = "\t";
      print map { $::HEADER[$_] } @::output_os;
      add_tally("T") if $B_print_tally;
      print "\n";
    }
    $Nrows++;
    next unless $B_headless;
  }
  else {
    $Nrows++;
  }

  if (!$B_headless && $::N+1 == @F) {
    print STDERR "-- adjusting for header row count discrepancy ($::N)\n" if $B_debug && $Nrows == 2;
    if ($Nrows == 2)            { $::extra_rownames = 1; }
    elsif (!$::extra_rownames)  { die "Row count inconsistency at line $.\n"; }
    $rowname = shift @F;
  }
  elsif ($::extra_rownames || $::N != @F) {
    die "Row count inconsistency at line $.\n";
  }

  do_compute(\@F);         # this pushes compute onto @F if present.

  my $nmatch = 0;
  for my $filt (@::filter) {
    my ($op, $indirection, $val, $colid) = @$filt;
    $val = $F[$val] if $indirection;
    $nmatch++ if $ops{$op}->($F[$colid], $val);
  }
  if (($nmatch < @::filter && $B_filter_and) || (!$nmatch && @::filter)) {
    $Nfilt++;
    next unless $B_print_tally;
  }

  print "$rowname\t" if defined($rowname) && $B_print_rowname;
  my @outputs = map { $F[$_] } @::output_os;

  local $" = "\t";
  print "@outputs";
  add_tally($nmatch) if $B_print_tally;
  print "\n";
}

print STDERR "-- $Ncmts comment lines in input\n" if $M_comment && $B_debug;
my $would = $B_print_tally ? ' would' : '';
print STDERR "-- $Nfilt rows$would have been filtered\n" if @::filter && $B_debug;


__DATA__

   s o m e   i d e a s
   -  operators to validate column type (integer, regex) .. half-exists already.
   -  tests
   ?  numerical comparisons check field is numeric
   ?  ord .. sprintf ..
   ?  per-column A/ep/4/0.1 B/ep/5/0.2
