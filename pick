#!/usr/bin/perl

       ##                                                                               ##
      ##      Pick columns and filter rows from tabular input, add derived columns       ##
     ##                 Pick and filter either by column name or index                    ##
    ##   Filter with numerical and string comparison operators and regular expressions.    ##
    ##                Filter on either existing columns or derived columns.                ##
     ##            Compute derived columns with string and algebraic operations.          ##
      ##                      Requires tab separated input.                              ##
       ##                See -H (EOH below) and -l (brief help)                         ##

                                      use strict;
                                     use warnings;

@::spec = @ARGV; @ARGV = ();
@::output_nm  = ();         # names - (header|1..N) + handles
@::output_os  = ();         # names translated to offsets
@::compute = ();
@::filter  = ();

%::handle_map = ();

my $CMT = '#';

my $B_print_header = 1;
my $B_filter_and   = 1;
my $B_verbose      = 0;
my $B_print_rowname = 0;    # cannot combine with $B_headless.
my $B_print_tally  = 0;
my $B_printall     = 0;
my $B_inplace      = 0;
my $B_excise       = 0;     # print all except unadorned columns listed, cannot combine with $B_printall
my $B_add_row_column = 0;
my $B_headless     = 0;
my $B_debug        = 0;
my $B_force        = 0;
my $M_comment      = 0;     # 0 oblivious, 1 strip, 2 pass

BEGIN {
  $::EPSILON = 0.0001; $::EPSILON = $ENV{EPSILON} if defined($ENV{EPSILON});
  $::OOM     = 2;      $::OOM     = $ENV{OOM}     if defined($ENV{OOM});
}

my %cp_opdefinitions =
   ( add       => [ 2, undef, sub { $::STACK[-2] += $::STACK[-1] } ],
     mul       => [ 2, undef, sub { $::STACK[-2] *= $::STACK[-1] } ],
     div       => [ 2, undef, sub { $::STACK[-2] /= $::STACK[-1] } ],
     cat       => [ 2, undef, sub { $::STACK[-2] .= $::STACK[-1] } ],
     sub       => [ 2, undef, sub { $::STACK[-2] -= $::STACK[-1] } ],
     mod       => [ 2, undef, sub { $::STACK[-2] %= $::STACK[-1] } ],
     pow       => [ 2, undef, sub { $::STACK[-2] **= $::STACK[-1] } ],
     and       => [ 2, undef, sub { $::STACK[-2] &= $::STACK[-1] } ],
     or        => [ 2, undef, sub { $::STACK[-2] |= $::STACK[-1] } ],
     xor       => [ 2, undef, sub { $::STACK[-2] ^= $::STACK[-1] } ],

     get       => [ 2, undef, sub { my $item =  $::STACK[-2] =~ /$::STACK[-1]/
                                                ? (defined($1) ? $1 : $&) : ""; $::STACK[-2] = $item; } ],

     ed        => [ 3, undef, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/  } ],
     edg       => [ 3, undef, sub { $::STACK[-3] =~ s/$::STACK[-2]/$::STACK[-1]/g } ],

     uc        => [ 1, undef, sub { $::STACK[-1] = uc($::STACK[-1]) }         ],
     lc        => [ 1, undef, sub { $::STACK[-1] = lc($::STACK[-1]) }         ],
     rot13     => [ 1, undef, sub { $::STACK[-1] = rot13($::STACK[-1]) }      ],
     len       => [ 1, undef, sub { $::STACK[-1] = length($::STACK[-1]) }     ],
     rc        => [ 1, undef, sub { $::STACK[-1] = rc($::STACK[-1]) }         ],
     abs       => [ 1, undef, sub { $::STACK[-1] = abs($::STACK[-1]) }        ],
     sqrt      => [ 1, undef, sub { $::STACK[-1] = sqrt($::STACK[-1]) }       ],
     sq        => [ 1, undef, sub { $::STACK[-1] = $::STACK[-1]**2 }          ],
     exp       => [ 1, undef, sub { $::STACK[-1] = exp($::STACK[-1]) }        ],
     cos       => [ 1, undef, sub { $::STACK[-1] = cos($::STACK[-1]) }        ],
     sin       => [ 1, undef, sub { $::STACK[-1] = sin($::STACK[-1]) }        ],
     tan       => [ 1, undef, sub { $::STACK[-1] = sin($::STACK[-1])/cos($::STACK[-1]) } ],
     log       => [ 1, undef, sub { $::STACK[-1] = log($::STACK[-1]) }        ],
     log10     => [ 1, undef, sub { $::STACK[-1] = log($::STACK[-1])/log(10) }],
     exp10     => [ 1, undef, sub { $::STACK[-1] = 10**$::STACK[-1] }         ],
     sign      => [ 1, undef, sub { $::STACK[-1] = $::STACK[-1] > 0 ? 1 : $::STACK[-1] < 0 ? -1 : 0 } ],
   );

my $s = 0;
@::CP_LIST = ();
for my $op (sort keys %cp_opdefinitions) {
   $::CP_LIST[$s] = $cp_opdefinitions{$op}[2];
   $cp_opdefinitions{$op}[1] = $s++;
}

            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
my %filterops = (
  '~'          => sub { $_[0] =~ /$_[1]/ },
  '/~'         => sub { $_[0] !~ /$_[1]/ },
  '='          => sub { $_[0] eq $_[1] },
  '/='         => sub { $_[0] ne $_[1] },
  '/ep/'       => sub { interval_plus(@_) },
  '/om/'       => sub { interval_mul(@_) },

  '/eq/'       => sub { $_[0] == $_[1] },
  '/ne/'       => sub { $_[0] != $_[1] },
  '/lt/'       => sub { $_[0] <  $_[1] },
  '/le/'       => sub { $_[0] <= $_[1] },
  '/ge/'       => sub { $_[0] >= $_[1] },
  '/gt/'       => sub { $_[0] >  $_[1] },

     # Perl behaves weirdly with bit operators in very specific cases; perhaps
     # because it thought both operands a string and one operand is negative.
     # E.g. perl -e '$x = "13" & "4"; $y = "13" + "4"; print "$x $y\n";'
     # yields 0 17
     # perl -e '$x = "-1" & "4"; $y = "-1" + "4"; print "$x $y\n";'
     # yields $ 3
     # This is to do with when/how perl sees something as a number or string. A
     # possible scenario is that perl considers fields resulting from string
     # splits as strings until treated as a number, but that the combination of
     # a bitwise operator and a negative-number-as-string does not lead to this
     # string-to-number promotion. "-1" & 4 and -1 & "4" both avoid the problem
     # - conceivably in both cases there is an operand that forces number
     # promotion.  Thus, absint.
     #
  '/all/'      => sub { $_[1] == (abs(int($_[0])) & abs(int($_[1]))) },
  '/any/'      => sub { abs(int($_[0])) & abs(int($_[1])) },
  '/none/'     => sub { ! (abs(int($_[0])) & abs(int($_[1]))) },

  '~eq~'       => sub { $_[0] eq $_[1] },
  '~ne~'       => sub { $_[0] ne $_[1] },
  '~lt~'       => sub { $_[0] lt $_[1] },
  '~le~'       => sub { $_[0] le $_[1] },
  '~ge~'       => sub { $_[0] ge $_[1] },
  '~gt~'       => sub { $_[0] gt $_[1] }
);

my $help_options=q{Options:
  -i in-place: <HANDLE>::<COMPUTE> replaces <HANDLE> if it exists
  -k headerless input, use 1 2 .. for column names
  -a print all input columns (filtering by colspec applies, -t accepted)
  -h do not print header
  -t do not filter, print tally column of count of matched row filters
  -o OR multiple criteria (default is AND)
  -v verbose
  -x take complement of selected input column(s) (works with -i)
  -r print rownames if row name field in header is the empty string.
    in this case _ is the name to select with <op> on rownames.
  -R add _ column if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically.
  -c strip lines starting with the comment sign (cf -/ option)
  -C pass lines starting with the comment sign unchanged (cf -/ option)
  -f force output (overrides identical output columns)
  -z print miscellaneous information, e.g. url encoding hex codes
  -/<str> treat <str> at beginning of line as comment line, e.g. -/@ for sam files

  options can be combined, use e.g. -kc/@ for headerless input, comment lines indicated by @ .
  -at is useful for inspecting/checking filters
  use -ai <name>::<COMPUTE> to change column <name> to <COMPUTE>,
  use -aik <num>::<COMPUTE> to change column <num> to <COMPUTE>.};

my $spec_forms = q{
  (1) <HANDLE>                 output <HANDLE> (column name, index, or derived compute name)
  (2) @<HANDLE><op><VAL>       filter criterion compare handle to constant value with <op>
  (3) @<HANDLE><op>:<HANDLE2>  filter criterion compare handle to other handle with <op>
  (4) <HANDLE>::<COMPUTE>      put <COMPUTE> in <HANDLE>
  (5) <HANDLE>:=<COMPUTE>      put <COMPUTE> in <HANDLE> and add <HANDLE> to output};

my @ops1 = sort grep { $cp_opdefinitions{$_}[0] == 1 } keys %cp_opdefinitions;
my @ops2 = sort grep { $cp_opdefinitions{$_}[0] == 2 } keys %cp_opdefinitions;
my @ops3 = sort grep { $cp_opdefinitions{$_}[0] == 3 } keys %cp_opdefinitions;
my @opsf = sort keys %filterops;

while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;
  $B_print_header = 0 if $options =~ /h/;
  $B_filter_and   = 0 if $options =~ /o/;
  $B_verbose      = 1 if $options =~ /v/;
  $B_print_rowname= 1 if $options =~ /r/;
  $B_print_tally  = 1 if $options =~ /t/;
  $B_printall     = 1 if $options =~ /a/;
  $B_excise       = 1 if $options =~ /x/;
  $B_add_row_column =1 if $options =~ /R/;
  $B_headless     = 1 if $options =~ /k/;
  $B_debug        = 1 if $options =~ /d/;
  $B_force        = 1 if $options =~ /f/;
  $B_inplace      = 1 if $options =~ /i/;
  $M_comment      = 1 if $options =~ /c/;
  $M_comment      = 2 if $options =~ /C/;
  $CMT = $1 if $options =~ /\/(.*)/;

  if ($options =~ /z/) {
    my @trickylist = split "", q{ <>!:;$%&`"'|(){}[]?*^-_+=@~/\#.,};
    my @trickyenc  = map { sprintf("%02X", ord($_)) } @trickylist;
    my $t1 = join "  ", @trickylist;
    my $t2 = join " ",  @trickyenc;
    print "$t1\n$t2\n";
    exit 0;
  }
  elsif ($options =~ /l/) {
    print $help_options, "\n";
    print "\nSelect/filter/compute forms:$spec_forms\n";
    print "\nOperators for compute:\n";
    print "  Take 1: @ops1\n";
    print "  Take 2: @ops2\n";
    print "  Take 3: @ops3\n";
    print "\nFilter comparison operators:\n";
    print "  @opsf\n";
    print "\nSee -H for longer description, including <COMPUTE> format and operators and filter operators.\n";
    exit 0;
  }
  elsif ($options =~ /H/) {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

<colspec>$spec_forms
See further below for <op> list.

$help_options

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a filter comparing a handle to a constant value. 
Form (3) creates a filter comparing a handle to another handle.
Form (4) creates a derived value in handle, <COMPUTE> specification below.
Form (5) as form 4, and selects the handle for output.

@<COLNAME><op>[^]<VAL>
@<COLNAME><op>:<COLNAME>
selects rows based on <VAL> or value in column <COLNAME>; see list below for <op>.
Colon introduces a column name; <VAL> is url-decoded; a leading ^ is removed.
<op> is one of the following:
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/  Aproximate numerical identity wrt VAL +- EPSILON; export variable EPSILON (current value $::EPSILON)
  /om/  Aproximate numerical identity wrt VAL * OOM, VAL / OOM (current value $::OOM, not sign aware)
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less than, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less than, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> will be url-decoded. In particular, if you need one of [%^:,]
  in <string> it is best to url-encode it with 25, 5E, 3A, 2C respectively.
  <handle> refers to a column name or an earlier computed derived column, or
  column index with -k (headerless input).  <op> is one of

Takes:
  1  | @ops1
  2  | @ops2
  3  | @ops3

  If the very first part starts anything other than [,:^] it is inferred to be a handle
  (leading : not needed).  <COMPUTE> is a stack, so zut::foo:bar,add^str,cat
  creates a new column called zut by adding columns foo and bar and then
  concatenating 'str'. The default operation is concatenation; if no operators
  are left the remainder of the stack is concatenated. Thus the above is
  equivalent to zut::foo:bar,add^str. To just prefix a column: zut::^foo:zut
  To concatenate two columns: zut::foo:bar . Below: get, ed and edg examples.

   :handle^str1,get      =>  handle =~ s/str1/MATCH/    # MATCH refers to () if present in str1, matched part otherwise.
   :handle^str1^str2,ed  =>  handle =~ s/str1/str2/     # str1 accepts most/all perl regular expression syntax.
   :handle^str1^str2,edg =>  handle =~ s/str1/str2/g    # str1 accepts most/all perl regular expression syntax.
EOH
  exit 0;
  }
}

die "-a -x do not combine\n" if $B_printall && $B_excise;
die "-r -k do not combine\n" if $B_print_rowname && $B_headless;
$B_print_header = 0 if $B_headless;

die "Need something (use -l for short help, -H for longer description)\n" unless @::spec || $B_printall;


sub interval_plus {
  my ($x, $y, $val) = @_;
  my $epsilon = $val ? $val : $::EPSILON;
  return $x <= $y + $epsilon && $x >= $y - $epsilon;
}

sub interval_mul {
  my ($x, $y, $val) = @_;
  my $oom = $val ? $val : $::OOM;
  return abs($x) <= abs($y) * $oom && abs($x) >= abs($y) / $oom;
}


my $TYPE_SCALAR = 1;
my $TYPE_HANDLE = 2;
my $TYPE_OPATOR = 3;    # (1) rule of six obvs, (2) it makes sense in Dutch.

my %chartypetonum = ( '^', $TYPE_SCALAR, ':', $TYPE_HANDLE, ',', $TYPE_OPATOR );

sub parse_stack {
  my ($handle, $spec) = @_;
  my @oplist = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[\/^:]/;
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]+)/g) {
    my ($type, $what) = ($chartypetonum{$1}, $2);
    $what = urldecode($what) if $type == $TYPE_SCALAR;
    push @oplist, [$type, $what];
    $p = pos($spec);
    if ($type == $TYPE_OPATOR) {
      my $def = $cp_opdefinitions{$what};
      die "Not supported [$what]\n" unless defined($def);
      push @{$oplist[-1]}, ($def->[0], $def->[1]);
print STDERR " >> $handle >> T=$type I=$what N=$def->[0], offset=$def->[1]\n" if $B_debug;
    }
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oplist;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


for my $spec (@::spec) {
     # fixme: ':=' or '::' cannot occur in handle in compute. url-decoding handle can remedy that.
  if ($spec =~ /(.*?)(:[:=])(.*)/) {
    my ($handle, $type, $compute) = ($1, $2, $3);
    my $stack = parse_stack($handle, $compute);
    push @::compute, [$handle, $stack];
    push @::output_nm, $handle if $type eq ':=';
  }
                #  H handle
                #  a1a2a3, b, c, d different forms for op
                #  V value or :handle
                #    ( H )([ a1](      a2    )[ a3]|  b    | c | d )( V)(  arg )
  elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~]|[=~]{1}|\/=|\/~)(.*?)(\/.*?)?$/) {
    my ($handle, $op, $val, $arg) = ($1, $2, $3, $4);
    die "Unrecognised operator [$op]\n" unless defined($filterops{$op});
    $arg = 0 unless defined($arg);
    $arg =~ s|^/||;
print STDERR "-- adding filter handle=[$handle] op=[$op] val=[$val] arg=[$arg]\n" if $B_debug;
    my $indirection = 0;
    if ($val =~ s/^://) {
      $indirection = 1;
    }
    else {
      $val = urldecode($val);
    }
                # NOTE. $arg for now only used by /ep/ and /om/ filters, ignored by the others.
    push @::filter, [$op, $indirection, $val, $handle, $arg];
  }
  else {
    push @::output_nm, $spec;
  }
}

sub add_tally {
  print "\t" if @::output_os; print $_[0];
}


sub wrangle_header {

  if ($::HEADER[0] eq '') { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_' }

  $::N = @::HEADER;
  my %inheader = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name});
    $::handle_map{$name} = $i;   
    print STDERR "-- Map header name $name to offset $i\n" if $B_debug;
  }

  print STDERR "-- Output column names as specified: @::output_nm\n" if $B_debug;
  if ($B_excise) {         # note excise we end up with input order.
    my %excise = map { ($_, 1) } @::output_nm;
    @::output_nm = ((grep { !defined($excise{$_}) } @::HEADER), (grep { !defined($inheader{$_}) } @::output_nm));
  }
  elsif ($B_printall) {
    print STDERR "-- Adding columns @::output_nm to header names\n" if @::output_nm && $B_debug;
    @::output_nm = (@::HEADER, grep { !defined($inheader{$_}) } @::output_nm);
  }
  print STDERR "-- Output column names after -i/-a treatment: @::output_nm\n" if $B_debug && ($B_excise || $B_printall);

  if ($B_print_header && keys %{{ map { ($_, 1) } @::output_nm }} < @::output_nm) {
    my $job = $B_force ? 'continuing' : 'fatal, use -f to force';
    print STDERR "-- Identical output column names exist ($job)\n";
    exit 1 unless $B_force;
  }

  #
  ##  Add derived column names to @::HEADER
  ##  In derived column specs replace names by offsets into field array.
  #

  for (my $i=0; $i<@::compute; $i++) {
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name already defined (use -i for in-place change)\n" if defined($::handle_map{$name}) && !$B_inplace;
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type == $TYPE_HANDLE) {
         die "Handle $what in compute $name does not reference a known entity\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};
      }
    }
    my $j = $::N + $i;
    $::HEADER[$j] = $name;        # only needed to print the new header.
    $::handle_map{$name} = $j;
    print STDERR "-- Map compute name $name to offset $j\n" if $B_debug;
  }

  #
  ##  In output list replace names by offsets into field array.
  #

  for (my $i=0; $i<@::output_nm; $i++) {
    my $name = $::output_nm[$i];
    die "Handle $name in output does not reference a known entity\n" unless defined($::handle_map{$name});
  }
  @::output_os = map { $::handle_map{$_} } @::output_nm;

print STDERR "-- output columns @::output_os --\n" if $B_debug;

  #
  ##  In filter list replace names by offsets into field array.
  #

  for my $filt (@::filter) {

    my ($op, $indirection, $val, $name, $arg) = @$filt;

    die "Handle $name in filter does not reference a known entity\n" unless defined($::handle_map{$name});
    $filt->[3] = $::handle_map{$name};
    if ($indirection) {
       die "Handle $val in filter does not reference a known entity\n" unless defined($::handle_map{$val});
       $filt->[2] = $::handle_map{$val};
    }
print STDERR "-- filter @$filt --\n" if $B_debug;

  }
}


sub do_compute {

  my $F = shift;

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    @::STACK = ();

    for my $comp (@$compute) {

      my ($type, $what, @other) = @$comp;

         if ($type == $TYPE_HANDLE) { push @::STACK, $F->[$what]; }
      elsif ($type == $TYPE_SCALAR) { push @::STACK, $what; }
      elsif ($type != $TYPE_OPATOR) { die "Really unfortunate!\n"; }

      else {
         my ($n_wanted, $offset) = @other;
         die "Stack underflow ($spic->[0] item [$what])\n" unless @::STACK >= $n_wanted;
         &{$::CP_LIST[$offset]};
         pop @::STACK while --$n_wanted;
      }
    }
    push @$F, (join "", @::STACK);
  }
  die "Cp error\n" unless @::HEADER == @$F;
}


my $Nrows = 0;    # includes header.
my $Ncmts = 0;
my $Nfilt = 0;
my $Nkeep = 0;

while (<>) {

  chomp;
  my @F = split "\t", $_, -1;
  my $rowname = undef;

  if ($M_comment && /^$CMT/) {
    print "$_\n" if $M_comment == 2;
    $Ncmts++;
    next;
  }
  elsif (!$Nrows) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    wrangle_header();
    if ($B_print_header) {
      local $, = "\t";
      print map { $::HEADER[$_] } @::output_os;
      add_tally("T") if $B_print_tally;
      print "\n";
    }
    $Nrows++;
    next unless $B_headless;
  }
  else {
    $Nrows++;
  }

  if (!$B_headless && $::N+1 == @F) {
    print STDERR "-- adjusting for header row count discrepancy ($::N)\n" if $B_verbose && $Nrows == 2;
    if ($Nrows == 2)            { $::extra_rownames = 1; }
    elsif (!$::extra_rownames)  { die "Row count inconsistency at line $.\n"; }
    $rowname = shift @F;
  }
  elsif ($::extra_rownames || $::N != @F) {
    die "Row count inconsistency at line $.\n";
  }

  do_compute(\@F);         # this pushes compute onto @F if present.

  my $nmatch = 0;
  for my $filt (@::filter) {
    my ($op, $indirection, $val, $colid, $arg) = @$filt;
    $val = $F[$val] if $indirection;
    $nmatch++ if $filterops{$op}->($F[$colid], $val, $arg);
  }
  if (@::filter && (($nmatch != @::filter && $B_filter_and) || ($nmatch == 0 && !$B_filter_and))) {
    $Nfilt++;
    next unless $B_print_tally;
  }
  else {
    $Nkeep++;
  }

  print "$rowname\t" if defined($rowname) && $B_print_rowname;
  my @outputs = map { $F[$_] } @::output_os;

  local $" = "\t";
  print "@outputs";
  add_tally($nmatch) if $B_print_tally;
  print "\n";
}

print STDERR "-- $Ncmts comment lines in input\n" if $M_comment && $B_verbose;
my $would = $B_print_tally ? ' would' : '';
print STDERR "-- $Nkeep/$Nfilt rows$would have been kept/filtered\n" if @::filter && $B_verbose;


__DATA__

   s o m e   i d e a s
   -  predefine constants (e.g. log10). new syntax?
   -  clearly define all interactions between -a, -i, -x, -f
   -  operators to validate column type (integer, regex) .. half-exists already.
   -  tests
   -  ifelse(filtername,compute1,compute2) is far beyond scope for now.
   ?  numerical comparisons check field is numeric
