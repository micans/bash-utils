#!/usr/bin/perl

# Pick and optionally filter columns from tabular input, add derived columns
# Pick either by column name or index
# Filter with numerical and string comparison operators and regular expressions.
# Filter on either existing columns or derived columns.
# Compute derived columns with string and algebraic operations.
# Requires tab separated input.

# See -H (EOH below).

# TODO: tests after the latest rewrite

# s o m e   i d e a s
# -  operators to validate column type (integer, regex) .. half-exists already.
# -  bit - and or, notand, notor
# ?  numerical comparisons check field is numeric
# ?  ord .. sprintf ..
# ?  per-column A/ep/4/0.1    B/ep/5/0.2
# ?  or COMPUTED can take operator to set epsilon and oom as side effect.

use strict;
use warnings;

@::spec = @ARGV; @ARGV = ();
@::output  = ();
@::compute = ();
@::filter  = ();

%::handle_map = ();

my $B_print_header = 1;
my $B_filter_or    = 0;
my $B_print_rowname = 0;    # cannot combine with $B_headless.
my $B_print_tally  = 0;
my $B_printall     = 0;
my $B_inplace      = 0;
my $B_excise       = 0;     # print all except unadorned columns listed, cannot combine with $B_printall
my $B_add_row_column = 0;
my $B_headless     = 0;
my $B_debug        = 0;
my $M_comment      = 0;       # 0 oblivious, 1 strip, 2 pass

BEGIN {
  $::EPSILON = 0.0001; $::EPSILON = $ENV{EPSILON} if defined($ENV{EPSILON});
  $::OOM     = 2; $::OOM     = $ENV{OOM} if defined($ENV{OOM});
}

while (@::spec && $::spec[0] =~ /^-/) {

  my $options = shift @::spec;
  $B_print_header = 0 if $options =~ /h/;
  $B_filter_or    = 1 if $options =~ /v/;
  $B_print_rowname= 1 if $options =~ /r/;
  $B_print_tally  = 1 if $options =~ /t/;
  $B_printall     = 1 if $options =~ /a/;
  $B_excise       = 1 if $options =~ /x/;
  $B_add_row_column =1 if $options =~ /R/;
  $B_headless     = 1 if $options =~ /k/;
  $B_debug        = 1 if $options =~ /d/;
  $B_inplace      = 1 if $options =~ /i/;
  $M_comment      = 1 if $options =~ /c/;
  $M_comment      = 2 if $options =~ /C/;

  if ($options =~ /z/) {
    my @trickylist = split "", q{ <>!;$&`"'|(){}[]?*^-_+=@~/\#.,};
    my @trickyenc  = map { sprintf("%02X", ord($_)) } @trickylist;
    my $t1 = join "  ", @trickylist;
    my $t2 = join " ",  @trickyenc;
    print "$t1\n$t2\n";
    exit 0;
  }
  if ($options =~ /H/) {
print <<EOH;
Usage: pick [options] <colspec>+ < FILE
Simple example: pick TAG ID < table.txt

  - Pick and optionally filter columns from tabular input.
  - Pick either by column name or index.
  - Filter with numerical and string comparison operators and regular expressions.
  - Combine columns with string and algebraic operations
  - Requires tab separated input.

<colspec>
  (1) <HANDLE>                 either column name or variable name for output
  (2) @<HANDLE><op><VAL>       filter criterion compare handle to constant value
  (3) @<HANDLE><op>:<HANDLE2>  filter criterion compare handle to other handle
  (4) <VARNAME>::<COMPUTE>     put <COMPUTE> in <VARNAME>

Options:
  -i in-place: all columns are output, NAME::<COMPUTE> replaces NAME if it exists
  -k headerless input, use 1 2 .. for column names
  -a print all input columns (filtering by colspec applies, -t accepted)
  -h do not print header
  -t print final tally column of count of matched column filters
  -v OR multiple criteria (default is AND)
  -x excise specified column(s) from the output (works with -i)
  -r print rownames if no column name for rownames exists;
    in this case _ is the name to select with <op> on rownames.
  -R add _ column if no row name field exists in the header;
    NOTE an empty field is recognised and mapped to _ automatically.
  -c strip lines starting with #
  -C pass lines with starting with # unchanged
  -z print miscellaneous information, e.g. url encoding hex codes

  -at is useful for inspecting/checking filters

<colspec>
HANDLE identifies either a column by name, or a derived value as in form (4).
Form (1) -- just a handle -- selects it for output.
Form (2) creates a filter comparing a handle to a constant value. 
Form (3) creates a filter comparing a handle to another handle.
Form (4) creates a derived value, see below for <COMPUTE> specification.

@<COLNAME><op>[^]<VAL>
@<COLNAME><op>:<COLNAME>
selects rows based on <VAL> or value in column <COLNAME>; see list below for <op>.
Colon introduces a column name; <VAL> is url-decoded.
  =     String identity accept
  /=    String identity reject
  ~     Substring/regular expression match accept
  /~    Substring/regular expression match reject
  /ep/  Aproximate numerical identity wrt VAL +- EPSILON; export variable EPSILON (current value $::EPSILON)
  /om/  Aproximate numerical identity wrt VAL * OOM, VAL / OOM (current value $::OOM, not sign aware)
  /eq|ne|lt|le|ge|gt/ numerical comparison (equal, not equal, less then, less than or equal etc)
  ~eq|ne|lt|le|ge|gt~  string   comparison (equal, not equal, less then, less than or equal etc)

<COMPUTE> is a concatenation of parts of the form (1) ^<string> (2) :<handle>
  (3) ,<op> . <string> will be url-decoded. <handle> is a column name, or column
  index with -k (headerless input) <op> is one of
    
    / add sub mul div
    \\ mod cat           (consume two   leave one)
    ed edg              (consume three leave one)       edit, edit global
    uc lc rot13         (consume two   leave one)       upper case, lower case, rot13

  If the very first part starts with [a-z] it is inferred to be a handle
  (leading : not needed).  <COMPUTE> is a stack, so zut::foo:bar,add^str,cat
  creates a new column called zut by adding columns foo and bar and then
  concatenating 'str'. The default operation is concatenation; if no operators
  are left the remainder of the stack is concatenated. Thus the above is
  equivalent to zut::foo:bar,add^str. To just prefix a column: zut::^foo:zut
  To concatenate two columns: zut::foo:bar .

    handle str1 str2 ed  =>  handle =~ s/str1/str2/
    handle str1 str2 edg =>  handle =~ s/str1/str2/g
EOH
  exit 0;
  }
}

die "-a -x do not combine\n" if $B_printall && $B_excise;
die "-r -k do not combine\n" if $B_print_rowname && $B_headless;
$B_print_header = 0 if $B_headless;

die "Need something (use -H for help)\n" unless @::spec || $B_printall;


sub interval_plus {
  my ($x, $y) = @_;
  return $x <= $y + $::EPSILON && $x >= $y - $::EPSILON;
}

sub interval_mul {
  my ($x, $y) = @_;
  return abs($x) <= abs($y) * $::OOM && abs($x) >= abs($y) / $::OOM;
}

            # $_[0] is $F[$i]
            # $_[1] is VAL or :VAL
my %ops = (
  '~'    => sub { $_[0] =~ /$_[1]/ },
  '/~'   => sub { $_[0] !~ /$_[1]/ },
  '='    => sub { $_[0] eq $_[1] },
  '/='   => sub { $_[0] ne $_[1] },
  '/ep/' => sub { interval_plus(@_) },
  '/om/' => sub { interval_mul(@_) },

  '/eq/' => sub { $_[0] == $_[1] },
  '/ne/' => sub { $_[0] != $_[1] },
  '/lt/' => sub { $_[0] <  $_[1] },
  '/le/' => sub { $_[0] <= $_[1] },
  '/ge/' => sub { $_[0] >= $_[1] },
  '/gt/' => sub { $_[0] >  $_[1] },

  '/all/' => sub  { local $" = ']['; my @y = @_; my $x = ($y[0] & $y[1]); my $z = (5 & -2.9); print "[@y][$x][$z]\n"; $_[1] == ($_[0] & $_[1]) },
  '/any/'  => sub { $_[0] & $_[1] },
  '/none/' => sub { ! ($_[0] & $_[1]) },

  '~eq~' => sub { $_[0] eq $_[1] },
  '~ne~' => sub { $_[0] ne $_[1] },
  '~lt~' => sub { $_[0] lt $_[1] },
  '~le~' => sub { $_[0] le $_[1] },
  '~ge~' => sub { $_[0] ge $_[1] },
  '~gt~' => sub { $_[0] gt $_[1] }
);

my %stackopnarg =
   ( add => 2, mul => 2, div => 2, cat => 2, sub => 2, mod => 2,
     ed  => 3, edg => 3,
     uc  => 1, lc => 1, rot13 => 1
   );

sub parse_stack {
  my $spec = shift;
  my @oppair = ();
  my $p = 0;
  $spec = ":$spec" if substr($spec, 0, 1) !~ /[\/^:]/;      # fixme what's the f slash for?
  my $l = length($spec);

  while ($spec =~ /([,^:])([^,^:]+)/g) {
    my ($type, $what) = ($1, $2);
    $what = urldecode($what) if $type eq '^';
    push @oppair, [$type, $what];
    $p = pos($spec);
    die "Not supported [$what]\n" if $type eq ',' && !defined($stackopnarg{$what});
  }
  die "Parse error in spec [$spec] near position $p\n" unless $p == $l;
  return \@oppair;
}

sub urldecode {
   my $val = shift;
   $val =~ s/%([A-Fa-f\d]{2})/chr hex $1/eg;
   return $val;
}


for my $spec (@::spec) {
  if ($spec =~ /(.*?)::(.*)/) {
    my ($handle, $compute) = ($1, $2);
    my $stack = parse_stack($compute);
    push @::compute, [$handle, $stack];
  }
  elsif ($spec =~ /^@(.*?)([\/~](?:[a-z]{2,4})[\/~]|[=~]{1}|\/=|\/~)(.*)/) {
    my ($handle, $op, $val) = ($1, $2, $3);
    die "Unrecognised operator [$op]\n" unless defined($ops{$op});
    my $indirection = 0;
    if ($val =~ s/^://) {
      $indirection = 1;
    }
    else {
      $val = urldecode($val);
    }
    push @::filter, [$op, $indirection, $val, $handle];
  }
  else {
    push @::output, $spec;
  }
}

sub add_tally {
  print "\t" if @::output; print $_[0];
}


sub wrangle_header {

  if ($::HEADER[0] eq '') { $::HEADER[0] = '_'; }
  elsif ($B_add_row_column) { unshift @::HEADER, '_' }

  $::N = @::HEADER;
  my %input_header = map { ($_, 1) } @::HEADER;

  for (my $i=0; $i<@::HEADER; $i++) {
    my $name = $::HEADER[$i];
    die "Name $name defined more than once\n" if defined($::handle_map{$name});
    $::handle_map{$name} = $i;   
  }

  for (my $i=0; $i<@::output; $i++) {
    my $name = $::output[$i];
    die "Handle $name in output does not reference a known entity\n" unless defined($::handle_map{$name});
  }

  if ($B_excise) {
    my %excise = map { ($_, 1) } @::output;
    @::output = grep { !defined($excise{$_}) } @::HEADER;
  }
  elsif ($B_printall) {
    @::output = @::HEADER;
  }

  for (my $i=0; $i<@::compute; $i++) {
    my $j = $::N + $i;
    my ($name, $compute) = @{$::compute[$i]};
    die "Name $name defined more than once\n" if defined($::handle_map{$name}) && !$B_inplace;
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;
      if ($type eq ':') {
         die "Handle $what in compute $name does not reference a known entity\n" unless defined($::handle_map{$what});
         $comp->[1] = $::handle_map{$what};
      }
    }
    $::handle_map{$name} = $j;
    push @::HEADER, $name;
  }

  for (my $i=0; $i<@::output; $i++) {
    my $name = $::output[$i];
    die "Handle $name in output does not reference a known entity\n" unless defined($::handle_map{$name});
    $::output[$i] = $::handle_map{$name};
  }

print STDERR "-- output columns @::output --\n" if $B_debug;

  for my $filt (@::filter) {

    my ($op, $indirection, $val, $name) = @$filt;
print STDERR "-- filter @$filt --\n" if $B_debug;

    die "Handle $name in filter does not reference a known entity\n" unless defined($::handle_map{$name});
    $filt->[3] = $::handle_map{$name};
    if ($indirection) {
       die "Handle $val in filter does not reference a known entity\n" unless defined($::handle_map{$val});
       $filt->[2] = $::handle_map{$val};
    }
  }
}


sub do_compute {

  my $F = shift;

  for my $spic (@::compute) {

    my ($handle, $compute) = @$spic;
    my @stack = ();
    for my $comp (@$compute) {
      my ($type, $what) = @$comp;

      if ($type eq ':') {
        push @stack, $F->[$what];
      }
      elsif ($type eq '^') {
        push @stack, $what;
      }
      elsif ($type eq ',') {
        my $n_wanted = $stackopnarg{$what};
        die "Stack underflow ($spic->[0])\n" unless @stack >= $n_wanted;
        if ($n_wanted == 2) {
           if ($what eq 'add') { $stack[-2] += $stack[-1] }
        elsif ($what eq 'cat') { $stack[-2] .= $stack[-1] }
        elsif ($what eq 'mul') { $stack[-2] *= $stack[-1] }
        elsif ($what eq 'sub') { $stack[-2] -= $stack[-1] }
        elsif ($what eq 'div') { $stack[-2] /= $stack[-1] }
        elsif ($what eq 'mod') { $stack[-2] %= $stack[-1] }
           pop @stack;
        }
        elsif ($n_wanted == 1) {
           if ($what eq 'uc') {  $stack[-1] = uc($stack[-1]) }
        elsif ($what eq 'lc') {  $stack[-1] = lc($stack[-1]) }
        elsif ($what eq 'rot13') {  $stack[-1] =~ tr/N-ZA-Mn-za-m/A-Za-z/ }
        }
        else {
           if ($what eq 'ed')  { $stack[-3] =~ s/$stack[-2]/$stack[-1]/ }
        elsif ($what eq 'edg') { $stack[-3] =~ s/$stack[-2]/$stack[-1]/g }
           pop @stack; pop @stack;
        }
      }
    }
    push @$F, (join "", @stack);
  }
  die "Cp error\n" unless @::HEADER == @$F;
}


while (<>) {

  chomp;
  my @F = split "\t";
  my $rowname = "";

  if ($. == 1) {
    @::HEADER = $B_headless ? (1..@F) : @F;
    wrangle_header();
    if ($B_print_header) {
      local $, = "\t";
      print map { $::HEADER[$_] } @::output;
      add_tally("T") if $B_print_tally;
      print "\n";
    }
    next unless $B_headless;
  }

  if (/^#/) {
    if ($M_comment) {
       print "$_\n" if $M_comment == 2;
       next;
    }
  }

  if (!$B_headless && $::N+1 == @F) {
    if ($. == 2)                { $::extra_rownames = 1; }
    elsif (!$::extra_rownames)  { die "Row count inconsistency at line $.\n"; }
    $rowname = shift @F;
  }
  elsif ($::extra_rownames || $::N != @F) {
    die "Row count inconsistency at line $.\n";
  }

  do_compute(\@F);         # this pushes compute onto @F if present.

  my $nmatch = 0;
  if (@::filter) {
    for my $filt (@::filter) {
      my ($op, $indirection, $val, $colid) = @$filt;
      $val = $F[$val] if $indirection;
      $nmatch++ if $ops{$op}->($F[$colid], $val);
    }
    next unless $B_print_tally || ($B_filter_or && $nmatch) || $nmatch == @::filter;
  }

  print "$rowname\t" if $rowname && $B_print_rowname;
  my @outputs = map { $F[$_] } @::output;

  local $" = "\t";
  print "@outputs";
  add_tally($nmatch) if $B_print_tally;
  print "\n";
}


